<!DOCTYPE html>
<html lang="zh_cn">
<head>
    <meta charset="utf-8">
    <title>Heriam</title>
    <meta name="description" content="">
    <meta name="author" content="Justin Time">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="baidu-site-verification" content="OGeiccsh1O" />
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
    <script src="https://jiang-hao.com/theme/html5.js"></script>
    <![endif]-->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" />
	<script async src="https://cdnjs.cloudflare.com/ajax/libs/echarts/4.2.1/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
    <script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script>

    <script src="https://jiang-hao.com/tipuesearch_content.js"></script>
    <link rel="stylesheet" href="https://jiang-hao.com/theme/tipuesearch/tipuesearch.css">
    <script src="https://jiang-hao.com/theme/tipuesearch/tipuesearch_set.js"></script>
    <script src="https://jiang-hao.com/theme/tipuesearch/tipuesearch.min.js"></script>
	<script src="https://jiang-hao.com/theme/bootstrap-collapse.js"></script>

    <!-- Le styles -->
    <link href="https://jiang-hao.com/theme/bootstrap.min.css" rel="stylesheet">
    <link href="https://jiang-hao.com/theme/bootstrap.min.responsive.css" rel="stylesheet">
    <link href="https://jiang-hao.com/theme/local.css" rel="stylesheet">
    <link href="https://jiang-hao.com/theme/pygments.css" rel="stylesheet">

    <!-- So Firefox can bookmark->"abo this site" -->

</head>

<body>
<a href="javascript:void(0);" id="scroll" title="Scroll to Top" style="display: none;">Top<span></span></a>
<div class="navbar">
    <div class="navbar-inner">
    <div class="container">

         <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
         </a>

        <a class="brand" href="https://jiang-hao.com">Heriam</a>

        <div class="nav-collapse">
        <ul class="nav">
            <li class="dropdown-jh"><a>Categories</a>
                <ul class="dropdown-content-jh">
                    <li><a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a></li>
                    <li><a href="https://jiang-hao.com/categories/backend.html">Backend</a></li>
                    <li><a href="https://jiang-hao.com/categories/big-data.html">Big Data</a></li>
                    <li><a href="https://jiang-hao.com/categories/cloud.html">Cloud</a></li>
                    <li><a href="https://jiang-hao.com/categories/frontend.html">Frontend</a></li>
                    <li><a href="https://jiang-hao.com/categories/networking.html">Networking</a></li>
                    <li><a href="https://jiang-hao.com/categories/notes.html">Notes</a></li>
                    <li><a href="https://jiang-hao.com/categories/tools.html">Tools</a></li>
                </ul>
            </li>

            <li><a href="/articles">Archives</a></li>
            <li><a href="/tags">Tags</a></li>
            <li><a href="/pages/publications">Publications</a></li>
            <li><a href="/pages/aboutme">AboutMe</a></li>
            
        </ul>

        <form class="navbar-search pull-right" action="https://jiang-hao.com/search.html" onsubmit="return validateForm(this.elements['q'].value);">
            <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input">
        </form>
        </div>
        
    </div>
    </div>
</div>

<div class="container">
    <div class="content">
    <div class="row">

        <div class="span9">
        
<section id="content" class="body">   
        


    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-bucket-sort.html"><h1>数据结构与算法——桶排序</h1></a>
<span class="metadata">
2020-12-20 Sun&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">算法简介</h2>
<p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，适用于待排序数据值域较大但分布比较均匀的情况。工作的原理是将数组元素分到有限数量的桶里，每个桶再各自排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p>
<p>桶排序的思想近乎彻底的<strong>分治思想</strong>。它是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p><img alt="img" src="https://img-blog.csdnimg.cn/20190219081232815.png"/></p>
<p>桶排序假设待排序的一组数均匀独立的分布在一个范围中，并将这一范围划分成几个子范围（桶）。然后基于某种映射函数f ，将待排序列的关键字 k 映射到第i个桶中 (即桶数组B 的下标i) ，那么该关键字k 就作为 B[i]中的元素 (每个桶B[i]都是一组大小为N/M 的序列 )。接着将各个桶中的数据有序的合并起来 : 对每个桶B[i] 中的所有元素进行比较排序 …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-bucket-sort.html">read more</a></div>
        <hr />
    </div>
		

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-radix-sort.html"><h1>数据结构与算法——基数排序</h1></a>
<span class="metadata">
2020-12-20 Sun&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">算法介绍</h2>
<p>基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序是稳定性的排序。</p>
<p>基数排序和桶排序、计数排序算法一样，都属于非比较型排序算法，且都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<p>冒泡、选择、插入、归并、希尔、堆、快速排序都是基于比较的排序，平均时间复杂度最低O(nlogn)；</p>
<p>计数排序、桶排序、基数排序不是基于比较的排序，使用空间换时间，某些时候，平均时间复杂度可以低于O(nlogn)。</p>
<p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列 …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-radix-sort.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-count-sort.html"><h1>数据结构与算法——计数排序</h1></a>
<span class="metadata">
2020-12-18 Fri&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">算法介绍</h2>
<p>计数排序（Counting sort）是一种稳定的线性时间排序算法。该算法于1954年由 Harold H. Seward 提出。计数排序使用一个额外的数组C ，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。</p>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>
<p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<p><img alt="img" src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif"/></p>
<p>我们使用下面的例子进行说明。</p>
<p>假设有20个随机整数，其取值范围在0~10之间，对其进行排序，由于这20个随机整数的取值范围是固定的，那么我们可以定义一个长度为11的数组，数组下标为从0到10，并且元素初始值全为0，然后遍历要排序的20个随机整数，将遍历到的数值对应的数组下标进行+1，直到遍历结束。如下图所示：</p>
<p>假设我们要遍历的20个随机数为 …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-count-sort.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-heap-sort.html"><h1>数据结构与算法——堆排序</h1></a>
<span class="metadata">
2020-12-17 Thu&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">算法介绍</h2>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ol>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ol>
<p>堆排序的平均时间复杂度为 Ο(nlogn)。</p>
<p>通常堆是通过一维<a href="https://zh.wikipedia.org/wiki/数组">数组</a>来实现的。在数组起始位置为0的情形中：</p>
<ul>
<li>父节点i的左子节点在位置<img alt="{\displaystyle (2i+1)}" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3bff8f7d580269fe6c1e35648032bf2b93354088"/>;</li>
<li>父节点i的右子节点在位置<img alt="{\displaystyle (2i+2)}" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e14787fdbf6c5580fcd2cf9f63c21dbeb8d82f5e"/>;</li>
<li>子节点i的父节点在位置<img alt="{\displaystyle floor((i-1)/2)}" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f38b28cfa0a788a6d767061ab7481da190b339b6"/>;</li>
</ul>
<p>在堆的<a href="https://zh.wikipedia.org/wiki/資料結構">数据结构</a>中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的<a href="https://zh.wikipedia.org/wiki/遞迴">递归</a>运算</li>
</ul>
<h2 id="_2">算法步骤 …</h2> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-heap-sort.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-quick-sort.html"><h1>数据结构与算法——快速排序</h1></a>
<span class="metadata">
2020-12-10 Thu&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-quick-sort.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-merge-sort.html"><h1>数据结构与算法——归并排序: 数组&链表&递归&非递归解法全家桶</h1></a>
<span class="metadata">
2020-11-29 Sun&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">算法介绍</h2>
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归：它从树的顶端开始，然后向下操作，每次操作都问同样的问题（我需要做什么来排序这个数组？）并回答它（分成两个子数组，进行递归调用，合并结果），直到我们到达树的底部。</li>
</ul>
<p><img alt="Picture2.png" src="https://pic.leetcode-cn.com/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png"/></p>
<ul>
<li>自下而上的迭代：不需要递归。它直接从树的底部开始，然后通过遍历这些片段再将它们合并起来。</li>
</ul>
<p><img alt="Picture1.png" src="https://pic.leetcode-cn.com/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png"/></p>
<p>在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：</p>
<blockquote>
<p>However, it is not possible to do so in JavaScript, as the recursion goes too deep …</p></blockquote> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-merge-sort.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-insert-sort.html"><h1>数据结构与算法——插入排序（扑克牌排序）</h1></a>
<span class="metadata">
2020-10-26 Mon&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">算法原理</h2>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。（有点像扑克牌在手上排序的过程）</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h3 id="_2">排序步骤</h3>
<p>将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<p>在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p>
<h3 id="_3">动图演示</h3>
<p><img alt="img" src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif"/></p>
<h2 id="_4">代码实现</h2>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">insert_sort_original</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">copyOf</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">valuationCnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="c1">// 赋值操作计数</span>
    <span class="kt">int</span> <span class="n">comparisonCnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="c1">// 比较操作计数</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i …</span></code></pre></div> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-insert-sort.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-shell-sort.html"><h1>数据结构与算法——希尔排序</h1></a>
<span class="metadata">
2020-10-26 Mon&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">算法原理</h2>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。<strong>该方法实质上是一种分组插入方法</strong>。</p>
<p>希尔排序把元素按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量 …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-shell-sort.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-selection-sort.html"><h1>数据结构与算法——选择排序</h1></a>
<span class="metadata">
2020-10-10 Sat&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">排序思想</h2>
<p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为<strong>选择排序</strong>。选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<p><img alt="img" src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif"/></p>
<p>那如何选出最小的一个元素呢？</p>
<p>很容易想到：先随便选一个元素假设它为最小的元素（默认为无序区间第一个元素），然后让这个元素与无序区间中的每一个元素进行比较，如果遇到比自己小的元素，那更新最小值下标，直到把无序区间遍历完，那最后的最小值就是这个无序区间的最小值。</p>
<h2 id="_2">算法性能</h2>
<p>选择排序是不稳定的排序方法。</p>
<h3 id="_3">时间复杂度</h3>
<p>选择排序的交换操作介于 0 和 (n - 1)次之间。选择排序的比较操作为 n(n - 1)/2 次。选择排序的赋值操作介于 0 和 3(n …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-selection-sort.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-algorithms-bubble-sort.html"><h1>数据结构与算法——冒泡排序</h1></a>
<span class="metadata">
2020-09-26 Sat&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">定义</h2>
<p>冒泡排序（Bubble Sort），是一种<a href="https://baike.baidu.com/item/计算机科学">计算机科学</a>领域的较简单的<a href="https://baike.baidu.com/item/排序算法/5399605">排序算法</a>。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<p><img alt="" src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif"/></p>
<h2 id="_2">算法原理</h2>
<p>冒泡<a href="https://baike.baidu.com/item/排序算法/5399605">排序算法</a>的原理如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。 </li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 </li>
</ol>
<p>算法复杂度是 O(n^2)，空间复杂度是常数 O(1)。但可以记录一个不需要交换的位置，把最好情况的时间复杂度降到 O(n)。详细可以参考下文优化部分的实现 …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-algorithms-bubble-sort.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-data-struct-linkedlist.html"><h1>数据结构与算法——链表</h1></a>
<span class="metadata">
2020-05-27 Wed&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">定义</h2>
<p>相比数组，链表是一种稍微复杂一点的数据结构。对于两者，我们常常将会放到一块儿来比较。</p>
<p><img onerror="this.src='https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg';this.onerror=null" src="https://heriam.coding.net/api/share/download/6bc1f6d2-5ed1-4216-84a4-b45459575b61"/></p>
<p>从图中我们看到，数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p>
<p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p>
<p>链表结构五花八门，主要有三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。我们首先来看最简单、最常用的单链表。</p>
<h2 id="_2">单向链表</h2>
<p>我们刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作后继指针 next。</p>
<p><img onerror="this.src='https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg';this.onerror=null" src="https://heriam.coding.net/api/share/download/7d29465c-1d47-4ddf-bfac-3edb5dee5cdd"/></p>
<p>其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址 …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-data-struct-linkedlist.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-data-struct-array.html"><h1>数据结构与算法——数组</h1></a>
<span class="metadata">
2020-05-26 Tue&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">定义</h2>
<p>数组（Array）是一种<strong>线性表</strong>数据结构。它用一组<strong>连续的内存空间</strong>，来存储一组具有<strong>相同类型</strong>的数据。</p>
<p>这个定义里有几个关键词，理解了这几个关键词，我想你就能彻底掌握数组的概念了。</p>
<p>首先是线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>
<p><img onerror="this.src='https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg';this.onerror=null" src="https://heriam.coding.net/api/share/download/f2574bf5-18d4-48a1-a7be-09116477a8ad"/></p>
<p>而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<p>第二个是连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
<h2 id="_2">随机访问</h2>
<p>我们拿一个长度为 10 的 int 类型的数组 …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-data-struct-array.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/algorithms-data-structure-n-algorithm-1.html"><h1>数据结构与算法——复杂度分析</h1></a>
<span class="metadata">
2020-05-24 Sun&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/algorithms.html">Algorithms</a>&nbsp;&nbsp;&nbsp;

 
</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">概述</h2>
<p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p>
<p>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。</p>
<p>想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。它几乎占了数据结构和算法这门课的半壁江山，是数据结构和算法学习的精髓。</p>
<p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。</p>
<p>下图几乎涵盖了所有数据结构和算法书籍中都会讲到的知识点：</p>
<p><img onerror="this.src='https://static001.geekbang.org/resource/image/91/a7/913e0ababe43a2d57267df5c5f0832a7.jpg';this.onerror=null" src="https://heriam.coding.net/api/share/download/e913ce75-a9af-4ac1-a7ce-b5d531ee9b0f"/></p>
<p>但是，作为初学者，或者一个非算法工程师来说，并不需要掌握图里面的所有知识点。下面总结了 20 个最常用的、最基础数据结构与算法，不管是应付面试还是工作需要，其实只要集中精力逐一攻克这 20 个知识点就足够了：</p>
<ul>
<li>
<p>10 个数据结构：<strong>数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树</strong>；</p>
</li>
<li>
<p>10 …</p></li></ul> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/algorithms-data-structure-n-algorithm-1.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2020/networking-vxlan-in-depth.html"><h1>VxLAN协议详解</h1></a>
<span class="metadata">
2020-03-12 Thu&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/networking.html">Networking</a>&nbsp;&nbsp;&nbsp;

 
 
    Tags: <a href="https://jiang-hao.com/tags/vxlan.html">VxLAN</a>,&nbsp;</span> 
        </div>
        
        <div class="summary">
<h2 id="vxlan">VxLAN简介</h2>
<h3 id="_1">背景</h3>
<p>任何技术的产生，都有其特定的时代背景与实际需求，VXLAN正是为了解决云计算时代虚拟化中的一系列问题而产生的一项技术。那么我们先看看 VXLAN 到底要解决哪些问题。</p>
<ul>
<li><strong>虚拟机规模受网络设备表项规格的限制</strong></li>
</ul>
<p>对于同网段主机的通信而言，报文通过查询MAC表进行二层转发。服务器虚拟化后，数据中心中VM的数量比原有的物理机发生了数量级的增长，伴随而来的便是虚拟机网卡MAC地址数量的空前增加。一般而言，接入侧二层设备的规格较小，MAC地址表项规模已经无法满足快速增长的VM数量。</p>
<ul>
<li><strong>传统网络的隔离能力有限</strong></li>
</ul>
<p>虚拟化（虚拟机和容器）的兴起使得一个数据中心会有动辄上万的机器需要通信，而传统的 VLAN 技术在标准定义中只有12比特，也就只能支持 4096 个网络上限，已经显然满足不了不断扩展的数据中心规模。</p>
<ul>
<li><strong>虚拟机迁移范围受限</strong></li>
</ul>
<p>虚拟机迁移，顾名思义，就是将虚拟机从一个物理机迁移到另一个物理机，但是要求在迁移过程中业务不能中断。要做到这一点，需要保证虚拟机迁移前后，其IP地址、MAC地址等参数维持不变。这就决定了，虚拟机迁移必须发生在一个二层域中。而传统数据中心网络的二层域，将虚拟机迁移限制在了一个较小的局部范围内。此外，解决这个问题同时还需保证二层的广播域不会过分扩大，这也是云计算网络的要求。</p>
<p>传统“二层+三层”的网络在应对这些要求时变得力不从心，虽然通过很多改进型的技术比如堆叠、SVF …</p> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2020/networking-vxlan-in-depth.html">read more</a></div>
        <hr />
    </div>
				

 
        

 

    <div class='article'>
        <div class="content-title">
            <a href="https://jiang-hao.com/articles/2019/backend-transactions-acid.html"><h1>深入理解大数据之——事务及其ACID特性</h1></a>
<span class="metadata">
2019-11-05 Tue&nbsp;&nbsp;&nbsp;

by <a class="url fn" href="https://jiang-hao.com/authors/justin-time.html">Justin Time</a>&nbsp;&nbsp;&nbsp;
 

Category: <a href="https://jiang-hao.com/categories/backend.html">Backend</a>&nbsp;&nbsp;&nbsp;

 
 
    Tags: <a href="https://jiang-hao.com/tags/acid.html">ACID</a>,&nbsp;<a href="https://jiang-hao.com/tags/consistency.html">Consistency</a>,&nbsp;<a href="https://jiang-hao.com/tags/database.html">Database</a>,&nbsp;</span> 
        </div>
        
        <div class="summary">
<h2 id="_1">事务简介</h2>
<h3 id="_2">事物的定义</h3>
<p>事务（Transaction）是由一系列对系统中数据进行访问或更新的操作所组成的一个程序执行逻辑单元（Unit）。在计算机术语中，事务通常就是指数据库事务 。</p>
<p><img alt="57355-20190323094924183-1338282146.png" src="https://i.loli.net/2019/11/05/iuoBJaNxb4H8Pgq.png"/></p>
<p>在数据库管理系统（DBMS）中，事务是数据库恢复和并发控制的基本单位。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p>
<p>例如，银行转帐工作：从源帐号扣款并使目标帐号增款，这两个操作必须要么全部执行，要么都不执行，否则就会出现该笔金额平白消失或出现的情况。所以，应该把他们看成一个事务。</p>
<p>在现代数据库中，事务还可以实现其他一些事情，例如，确保你不能访问别人写了一半的数据；但是基本思想是相同的——事务是用来确保<strong>无论发生什么情况，你使用的数据都将处于一个合理的状态</strong>：</p>
<blockquote>
<p>transactions are there to ensure, that no matter what happens, the data you work with will be in …</p></blockquote> <a class="btn btn-info xsmall" href="https://jiang-hao.com/articles/2019/backend-transactions-acid.html">read more</a></div>
        <hr />
    </div>
				
<div class="pagination">
<ul>
    <li class="prev disabled"><a href="#">&lsaquo; Previous</a></li>

    <li class="active"><a href="https://jiang-hao.com/index.html">1</a></li>
    <li class=""><a href="https://jiang-hao.com/index2.html">2</a></li>
    <li class=""><a href="https://jiang-hao.com/index3.html">3</a></li>

    <li class="next"><a href="https://jiang-hao.com/index2.html">Next &rsaquo;</a></li>

</ul>
</div>
 
  </section>
        </div>
        
        <div class="span3">
		
		    <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
    			<div style="width:80%; margin:0 auto;">
                    <div style="text-align: center;">
						<a href="/" class="profilepic">
                            <img src="https://i.loli.net/2019/10/31/TRSQt7aKkx6DdBA.png" οnerrοr="this.onerror=null;this.src='https://raw.githubusercontent.com/Heriam/images/master/portrait/photo-zzz.png';" alt="photo-zzz.png" title="photo-zzz.png" />
						</a>
						<h1><span class="mainTitle">Hao Jiang</span><span class="subTitle">Justin Time</span></h1>
						<p class="motto">We only live once, and time just goes by.</p>
						<ul class="biography">
						<li><span><img src="https://jiang-hao.com/theme/images/icons/work.svg" class="listIcon"></span><span>R&amp;D Engineer <a href="http://www.h3c.com" target="_blank">@H3C</a></span></li>
						<li><span><img src="https://jiang-hao.com/theme/images/icons/location.svg" class="listIcon"></span><span>Hangzhou, China</span></li>

					<hr>

						<div class="tooltip">
							<span class="tooltiptext">Facebook</span>
							<a href="https://www.facebook.com/hao.zju" target="_blank" class="socialLink" style="background: url(https://jiang-hao.com/theme/images/icons/Facebook.svg) center no-repeat"></a>
						</div>
						<div class="tooltip">
							<span class="tooltiptext">微博</span>
							<a href="http://weibo.com/207575725" target="_blank" class="socialLink" style="background: url(https://jiang-hao.com/theme/images/icons/微博.svg) center no-repeat"></a>
						</div>
						<div class="tooltip">
							<span class="tooltiptext">Linkedin</span>
							<a href="http://www.linkedin.com/in/haochiang" target="_blank" class="socialLink" style="background: url(https://jiang-hao.com/theme/images/icons/Linkedin.svg) center no-repeat"></a>
						</div>
						<div class="tooltip">
							<span class="tooltiptext">Github</span>
							<a href="https://github.com/Heriam" target="_blank" class="socialLink" style="background: url(https://jiang-hao.com/theme/images/icons/Github.svg) center no-repeat"></a>
						</div>
						<div class="tooltip">
							<span class="tooltiptext">Email</span>
							<a href="mailto:jiang.haoa@h3c.com" target="_blank" class="socialLink" style="background: url(https://jiang-hao.com/theme/images/icons/Email.svg) center no-repeat"></a>
						</div>
						<div class="tooltip">
							<span class="tooltiptext">Instagram</span>
							<a href="https://www.instagram.com/heriam_j/" target="_blank" class="socialLink" style="background: url(https://jiang-hao.com/theme/images/icons/Instagram.svg) center no-repeat"></a>
						</div>
						<div class="tooltip">
							<span class="tooltiptext">ResearchGate</span>
							<a href="https://www.researchgate.net/profile/Hao_Jiang59" target="_blank" class="socialLink" style="background: url(https://jiang-hao.com/theme/images/icons/ResearchGate.svg) center no-repeat"></a>
						</div>
						<div class="tooltip">
							<span class="tooltiptext">知乎</span>
							<a href="https://www.zhihu.com/people/justin-time" target="_blank" class="socialLink" style="background: url(https://jiang-hao.com/theme/images/icons/知乎.svg) center no-repeat"></a>
						</div>
						<div class="tooltip">
							<span class="tooltiptext">OSChina</span>
							<a href="https://my.oschina.net/heriam" target="_blank" class="socialLink" style="background: url(https://jiang-hao.com/theme/images/icons/OSChina.svg) center no-repeat"></a>
						</div>
					</div>
                </div>
            </div>

	        <div class="well" style="padding: 0 0; background-color: #FBFBFB;">
                <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

                <ins class="adsbygoogle"
                     style="display:inline-block;width:268px;height:268px"
                     data-ad-client="ca-pub-8185340840770803"
                     data-ad-slot="3077290298"></ins>
                <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
            </div>

        </div>  
    </div>     </div> 
<footer>
<br />
<p><a href="https://jiang-hao.com">Heriam</a> &copy; Justin Time 2020.&nbsp;All rights reserved.</p>
</footer>

</div> <!-- /container -->
<script>var _gaq=[['_setAccount','UA-137721527-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
 
<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<script>
    function validateForm(query)
    {
        return (query.length > 0);
    }
</script>
<meting-js
    server="netease"
    type="playlist"
    id="43561591"
    fixed="true"
    order="list"
    volume="1.0"
    list-folded="true"
    >
</meting-js>
</body>
</html>