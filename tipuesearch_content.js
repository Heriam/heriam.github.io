var tipuesearch = {"pages":[{"url":"pages/home.html","text":"Hao serves as an R&D Engineer at New H3C Technologies . In early 2017, He completed EIT Digital Dual Master Degree Programme with a major of Internet Technology and Architecture at KTH Royal Institute of Technology and a specialization of Internet of Things(IoT) at IMT Atlantique . He also minored in ICT Innovation and Entrepreneurship during his Master studies. Hao is a Cisco Certificated Internetwork Expert in Routing and Switching (CCIE R&S #40343). He is passionate about future networking technologies. His interests mainly focus on Wireless and Mobile Networking , Datacenter and Cloud Networking , and Network Intelligence(Big Data, AI, etc.) . He is highly motivated by the desire to see these technologies meet together to shape a more intelligent, efficient, and reliable networked society. His curriculum vitae is available here . You can also find him on Linkedin . 现就职于 H3C 担任研发工程师。2017年初完成欧盟 EIT Digital 双硕士学位联合培养项目，分别获得 KTH瑞典皇家理工学院 的互联网技术与架构硕士学位和 IMT Atlantique法国大西洋高等矿业电信学校 的物联网硕士学位，以及ICT创新创业商科辅修证书。2016年3月至9月在 思科 巴黎创新研究院进行硕士毕业论文实习。2014年本科毕业于 浙江大学 环境与资源学院并获得农学学士学位。 思科认证互联网络专家（CCIE R&S #40343），也是未来网络技术的狂热爱好者。兴趣主要集中在无线和移动网络，数据中心和云计算网络，以及网络大数据/人工智能等领域。期待这些技术融合后构建一个更加智能、高效和可靠的互联社会。 详细简历请戳 这里 。您也可以在 领英 上找到我。","tags":"pages","loc":"pages/home.html","title":"About me"},{"url":"pages/management.html","text":"document.write('<link rel=\"stylesheet\" href=\"https://raw.githubusercontent.com/Heriam/schedule-template/master/css/reset.css\"><link rel=\"stylesheet\" href=\"https://raw.githubusercontent.com/Heriam/schedule-template/master/css/style.css\"><script src=\"https://raw.githubusercontent.com/Heriam/schedule-template/master/js/modernizr.js\"><\\/script><script src=\"https://raw.githubusercontent.com/Heriam/schedule-template/master/js/main.js\"><\\/script>'); 09:00 09:30 10:00 10:30 11:00 11:30 12:00 12:30 13:00 13:30 14:00 14:30 15:00 15:30 16:00 16:30 17:00 17:30 18:00 Monday Abs Circuit Rowing Workout Yoga Level 1 Tuesday Rowing Workout Restorative Yoga Abs Circuit Yoga Level 1 Wednesday Restorative Yoga Yoga Level 1 Rowing Workout Yoga Level 1 Thursday Abs Circuit Restorative Yoga Abs Circuit Rowing Workout Friday Rowing Workout Abs Circuit Yoga Level 1 Close","tags":"pages","loc":"pages/management.html","title":"Self Management"},{"url":"pages/publications.html","text":"论文 2019 \"A JSON-Based Fast and Expressive Access Control Policy Framework\". H. Jiang and A. Bouabdallah. Advanced Data Modeling and Processing With JSON. To be published by IGI Global in 2019. 2017 \"JACPoL: A Simple but Expressive JSON-based Access Control Policy Language\". H. Jiang and A. Bouabdallah. Wistp 2017: International Conference on Information Security Theory and Practice, Springer Verlag, 28-29 September 2017. \"Towards a JSON-Based Fast Policy Evaluation Framework\". H. Jiang and A. Bouabdallah. In OTM Confederated International Conferences \"On the Move to Meaningful Internet Systems\", pp. 22-30. Springer, Cham, 2017. \"Controlled Replication for Higher Reliability and Predictability in Industrial IoT Networks\". H. Jiang , Z. Brodard, T.F. Chang, A. Bouabdallah, N. Montavont, G. Texier, P. Thubert, T. Watteyne, G. Z. Papadopoulos. In Proceedings of the 2017 International Conference on Embedded Wireless Systems and Networks (EWSN), Dependability Competition, ACM, Uppsala, Sweden, February 20-22, 2017. 2016 \"Rover: Poor (but Elegant) Man's Testbed\". Z. Brodard, H. Jiang , T.F. Chang, T. Watteyne, X. Vilajosana, P. Thubert, G. Texier. In Proceedings of the 13th ACM Symposium on Performance Evaluation of Wireless Ad Hoc, Sensor, and Ubiquitous Networks (PE-WASUN 2016). pp. 61-65. ACM. November 17, 2016. \"A Secure Multi-Tenant Framework for SDN\". H. Jiang , A. Bouabdallah, A. Aflatoonian, J. M. Bonnin, K. Guillouard. In Proceedings of the 9th International Conference on Security of Information and Networks(SIN 2016). pp. 40-44. ACM, July 20, 2016. 专利 2016 \"Timeslot Shifting for Lower-Priority Packets in a Time Slotted Network\". P. Thubert, Z. Brodard, H. Jiang . U.S.Patent 15/207,621 filed 12-Jul-2016. 标准 2016 \"A 6loRH for Bit Strings\". P. Thubert, Z. Brodard, H. Jiang , & G. Texier. IETF Internet draft. Version: draft-thubert-6lo-bier-dispatch-01. IETF 6lo WG. June 29, 2016. \"BIER-TE-based OAM, Replication & Elimination\". P. Thubert, Z. Brodard, H. Jiang . IETF Internet draft. Version: draft-thubert-bier-replication-elimination-00. IETF BIER WG. September 14, 2016. ​ 其它 2016 \"Software-defined IoT: 6TiSCH Centralized Scheduling and Multipath Construction\". H. Jiang . Internship report (Master Thesis). Cisco Paris Innovation and Research Lab, September 21, 2016. \"A Secure Multi-tenant Framework on the Northbound Side of SDN\". H. Jiang . Innovation project report. Department of Network, Security and Multimedia, Telecom Bretagne, March 07, 2016. 2014 未来互联网试验床资源管控系统的设计与实现/ Design and Implementation of Resource Management and Control System for Future Internet Testbed (in Chinese). H. Jiang . Bachelor thesis. Next Generation Network Technology Laboratory (NGNT Lab), College of Computer Science and Technology, Zhejiang University, June 10, 2014. 2013 CCIE笔记-路由交换理论和实战/ CCIE Notes - Routing and Switching (in Chinese). H. Jiang . August 27, 2013.","tags":"pages","loc":"pages/publications.html","title":"Publications"},{"url":"pages/resume.html","text":"Last Updated: Feb 25, 2018 Hao JIANG Research & Development Engineer, New H3C Technologies Co., Limited Email: jiang DOT haoa AT h3c DOT com Address: 466 Changhe Road, Binjiang District, 310052 Hangzhou SUMMARY A 2-year-old master graduate with double degrees in Internet Technology and Architecture & Internet of Things(IoT) from EIT Digital Program, and a minor certificate in Innovation and Entrepreneurship . Possess extensive knowledge in IoT Data Communication and Management & Datacenter and Cloud Networking technologies. Understand deeply IP network architecture, protocols, and popular techniques. Master common system programming languages, e.g., Java, Python, C/C++. EDUCATION M.Sc. in Internet of Things, IMT Atlantique, GPA: 3.85/3.9, 2015/2016 M.Sc. in Internet Technology and Architecture, KTH Royal Institute of Technology, GPA: 4.61/5.0, 2014/2015 B.Sc. in Agricultural Resources and Environment, Zhejiang University, GPA: 3.66/4.0, 2010-2014 SELECTED HONORS & AWARDS Excellence Scholarship, 1000€/month+3000€ mobility allowance, sponsored by EIT Digital, 09/2014 - 08/2016 Outstanding Collegiate Volunteer, awarded by Chinese Society for Environmental Sciences (CSES), 03/2013 National Endeavor Scholarship, 5000¥, sponsored by Ministry of Education of China, 12/2012 Excellent Student Awards, awarded by Zhejiang University, 12/2012 Outstanding Student Leader Awards, Top 6%, awarded by Zhejiang University, 10/2012 Academic Excellence Scholarship, Top 15%, sponsored by Zhejiang University, 10/2012 Outstanding Student Scholarship, sponsored by Zhejiang University, 10/2011 Scholarship for Outstanding Students, Top 1‰, sponsored by Yifeng Middle School of Jiangxi, China, 09/2007 - 06/2010 R&D EXPERIENCE R&D Engineer at New H3C Technologies Co., Limited, from 11/2017 Topic: SDN Research and Development R&D Engineer at Telecom Bretagne, 11/2016 - 08/2017 Topic: Trustful Hyper-linked Entities in Dynamic Networks Participated in the reThink project under the European Horizon 2020 Programme. Designed and developed JACPoL: a scalable, expressive but lightweight JSON-based access control policy language. Prototyped a performant policy evaluation engine associated with JACPoL adopting PEP/PDP architecture. Published 2 papers. Research Intern (Master Thesis) at Cisco Paris Innovation and Research Lab, 03/2016 - 09/2016 Topic: Software Defined Internet of Things (SDIoT) - 6TiSCH Centralized Scheduling and Multipath Construction Developed SDN-based routing and resource allocation schemes for deterministic IoT Low-power Lossy Networks (LLNs). Designed, implemented, and evaluated a multipath forwarding and control mechanism based on IPv6 over the TSCH mode of IEEE 802.15.4e (6TiSCH). Co-authored 3 papers, 2 Internet drafts at Internet Engineering Task Force (IETF), and 1 patent. Contributed actively to OpenWSN open-source projects. Independent Study at Telecom Bretagne, 11/2015 - 02/2016 Topic: A Secure Northbound Multi-tenant Framework for Software-defined Networks (SDN) Designed and implemented a novel multi-tenant framework with AAA, MySQL, and RESTful web services on top of OpenDaylight controller. Published the research and brought up a new concept of Software Defined Multi-tenant Networking (SDMTN). Research Intern (Bachelor Thesis) at Laboratory of Next Generation Network Technology (NGNT Lab), Zhejiang University, 02/2014 - 06/2014 Topic: Resource Management and Control for a Large-scale SDN Testbed Designed and implemented virtual-to-physical network mapping and resource allocation mechanisms for the data plane. Summer Intern at Institute of Agricultural Remote Sensing and Information Technology, Zhejiang University, 06/2013 - 08/2013 Topic: Greenhouse Environment Monitoring and Automatic Control Programmed on wireless sensor nodes with TinyOS/nesC. Conducted Matlab simulations for greenhouse energy-efficiency analysis. EXTRACURRICULAR ACTIVITIES Member of the Preparatory Committee of EU-China Youth Innovation & Entrepreneurship Forum 2017, 11/2016 - 06/2017 Participating actively in the design and preparation of the forum to promote cooperation and exchange between Chinese and European investors and start-up companies. Director of EIT CSSA (Chinese Students and Scholars Association) France, 10/2015 - 09/2016 Organized academic and recreational activities among EIT Digital students over European countries. Teaching Assistant at OpenLab IT Education, Inc., Hangzhou, 08/2013 - 01/2014 Offered technical courses on routing, switching, and troubleshooting technologies. Performed periodical maintenance of teaching materials and translation of technical documents. Director of General Affairs Department of Students' Union, Zhejiang University, 09/2011 - 09/2012 Organized a variety of campus and volunteer activities. Received Outstanding Student Leader Awards from Zhejiang University. English Tutor for a junior middle school student, 09/2011 - 02/2012 Student Technician of IT Support Center, Zhejiang University, 09/2010 - 06/2011 Supported students and faculty in solving computer and network problems. Figured out and solved the problem of DHCP failure once in a campus wireless network paralysis. TECHNICAL COURSE PROJECTS Multitasking and Event Scheduling on Wireless Sensor Networks , 01/2016-02/2016 UVDECX101-Distributed Architectures and Embedded Systems, Télécom Bretagne Developed smart LED lighting control using networked Contiki motes with distributed sensing and actuation. IoT Data Stream Processing and Analytics , 11/2015-12/2015 UVDECX501-Internet of Things and Intelligent Transport, Télécom Bretagne Analysed real-time data stream from campus wireless sensor network using Apache Storm. Performance Analysis of Backoff Algorithms in WiFi Networks , 01/2015-03/2015 IK2217-Advanced Internetworking II, KTH Royal Institute of Technology Evaluated and improved the backoff mechanism in CSMA wireless networks to optimize throughput performance through NS3 simulation. 5G Wireless System with Massive MIMO , 11/2014-01/2015 EP2950-Wireless Networks, KTH Royal Institute of Technology Investigated novel techniques of massive MIMO as a key enabler for 5G based on extensive literature research. Advanced ISP (Internet Service Provider) Networking , 09/2014-11/2014 IK2215-Advanced Internetworking, KTH Royal Institute of Technology Designed and implemented high availability inter/intra-domain routing functions, IP multicast, along with a suite of DNS, DHCP, Web, FTP, Mail, VPN, Firewall and IPS/IDS services. Traffic Light Control Based on PLC (Programmable Logic Controller) , 11/2012-01/2013 101C0020-Electrical and Electronic Experiment, Zhejiang University Designed and implemented a traffic light PLC program through ladder logic using LogixPro Simulator. BUSINESS COURSE PROJECTS An Assessment of the Business Opportunity in Telehealth Industry , 09/2016 Minor Thesis, EIT Digital Master Programme Investigated extensively key technologies and market environment for health monitoring wearable products. Proposed a novel business model based on open and user innovation paradigm. Intellitest - Loved by Everyone Except Cheaters , 07/2015-08/2015 ME2078-Summer School: Security & Privacy in Digital Life, University of Trento Designed a smart anti-cheating system integrating machine learning capabilities to make online exams more trustful. Received the top 3 best entrepreneurial team prize. Locate - Locate Things Easily , 04/2015-05/2015 ME2073-Business Development Lab of Entrepreneurship Engineers, KTH Designed, validated and developed a complete business plan with a focus on the value proposition and customer validation of personal Internet of Things products. GreenCoating , 10/2012-09/2013 National Student Research Training Program (SRTP), Zhejiang University Led the development of a plant-derived antibacterial coating additive based on mentor's patents, in cooperation with Hangzhou Risun Chemical Technology Co., LTD. Received sponsorship also from National College Student Entrepreneurship Training Program(SIETP). CCIE CERTIFICATION TRACKS CCIE (Cisco Certificated Internetwork Expert) Data Center Written Exam, Score: 984/1000, Stockholm 05/2015 CCIE Routing and Switching Lab Exam, PASS, License #40343, Beijing 08/2013 CCIE Routing and Switching Written Exam, Score: 972/1000, Hangzhou 03/2013 SKILLS Programming: Python, Java, C/C++, JavaScript, HTML, CSS, Shell, SQL Networking: TCP/IP, Software-defined Networking, Wireless and Mobile Networking, Multimedia Networking Tools: JetBrains IDEs, Microsoft Office, Adobe Creative Suite, MySQL Platforms: Linux, Mac OS, Windows Languages: Chinese (native), English (professional), French (elementary) VOLUNTEER EXPERIENCE Environmental Volunteer of Hangzhou scenic areas, 03/2014 Kept the scenic environment clean, and the gardens out of damage. Inspired the environmental awareness of tourists. Lead Volunteer of Public Environmental Education, Anji, Zhejiang Province, China, 07/2012 - 08/2012 Organized a set of public environmental education activities with topics on plant protection, waste classification, and energy conservation with 30 volunteers. Presented as a good example and received Outstanding Collegiate Volunteer awards in the annual conference of Chinese Society for Environmental Sciences. Teaching Volunteer in Shilian Primary School of Suichang, Zhejiang Province, China, 07/2011 – 08/2011 Served as a Chinese teacher for more than 20 pupils during the summer holiday. PUBLICATION \"JACPoL: A Simple but Expressive JSON-based Access Control Policy Language\". H. Jiang and A. Bouabdallah. Wistp 2017: International Conference on Information Security Theory and Practice, Springer Verlag, 28-29 September 2017. \"Towards a JSON-Based Fast Policy Evaluation Framework\". H. Jiang and A. Bouabdallah. In OTM Confederated International Conferences \"On the Move to Meaningful Internet Systems\", pp. 22-30. Springer, Cham, 2017. \"Controlled Replication for Higher Reliability and Predictability in Industrial IoT Networks\". H. Jiang , Z. Brodard, T.F. Chang, A. Bouabdallah, N. Montavont, G. Texier, P. Thubert, T. Watteyne, G. Z. Papadopoulos. In Proceedings of the 2017 International Conference on Embedded Wireless Systems and Networks (EWSN), Dependability Competition, ACM, Uppsala, Sweden​, February 20-22, 2017. \"Rover: Poor (but Elegant) Man's Testbed\". Z. Brodard, H. Jiang , T.F. Chang, T. Watteyne, X. Vilajosana, P. Thubert, G. Texier. In Proceedings of the 13th ACM Symposium on Performance Evaluation of Wireless Ad Hoc, Sensor, and Ubiquitous Networks (PE-WASUN 2016). pp. 61-65. ACM. November 17, 2016. \"A Secure Multi-Tenant Framework for SDN\". H. Jiang , A. Bouabdallah, A. Aflatoonian, J. M. Bonnin, K. Guillouard. In Proceedings of the 9th International Conference on Security of Information and Networks(SIN 2016). pp. 40-44. ACM, July 20, 2016. \"Timeslot Shifting for Lower-Priority Packets in a Time Slotted Network\". P. Thubert, Z. Brodard, H. Jiang . U.S.Patent 15/207,621 filed 12-Jul-2016. \"A 6loRH for Bit Strings\". P. Thubert, Z. Brodard, H. Jiang , & G. Texier. IETF Internet draft. Version: draft-thubert-6lo-bier-dispatch-01. IETF 6lo WG. June 29, 2016. \"BIER-TE-based OAM, Replication & Elimination\". P. Thubert, Z. Brodard, H. Jiang . IETF Internet draft. Version: draft-thubert-bier-replication-elimination-00. IETF BIER WG. September 14, 2016.","tags":"pages","loc":"pages/resume.html","title":"Resume"},{"url":"pages/search.html","text":"$(document).ready(function() { $('#tipue_search_input').tipuesearch(); });","tags":"pages","loc":"pages/search.html","title":"Search Results"},{"url":"articles/2019/tools-Cloud-Desktop-Based-On-MegaSync.html","text":"Demo Here is a demo showing a \"cloud\" desktop: If you don't like application icons and want to only have files and folders on desktop (as shown in the picture), but still want to be able to launch applications in a convenient way, you can remove all the icons, and install WOX for quickly accessing applications. Using MEGASync, you can synchronize your desktop among multiple devcies and access your documents anywhere with Internet connection. MEGASync MEGASync provides following functionalities: - secure cloud netdisk with 50GB free storage - fast transfers with end-to-end encryption - folder synchronization among multiple devices As we can see, a very useful function of MEGASync is to synchronize folders among multiple devices. But it would become more interesting when we use it to put our desktop in the cloud. HOWTO The configuration is very easy, just include the desktop directory for synchronization when setting up MEGASync.","tags":"Tools","loc":"articles/2019/tools-Cloud-Desktop-Based-On-MegaSync.html","title":"Put your desktop in the cloud using MEGASync"},{"url":"articles/2019/coding-AJavaTFTPServer.html","text":"简介 一个完全多线程的tftp服务器。可以同时处理多个客户端。实现 RFC 1350 并包装块号以获得大文件支持。 通过判断监听到的请求tftpPacket_的类型是TFTPReadRequestPacket（读）或者TFTPWriteRequestPacket（写），将其对应交由handleRead()或者handleWrite()方法处理。 要启动，只需创建该类的实例。如果服务器由于正在使用的端口，端口被拒绝等原因而无法启动，则将抛出IOException。 要停止，请使用shutdown方法。 要检查服务器是否仍在运行（或者由于错误而停止），请调用isRunning方法。 默认情况下，事件不会记录到stdout/stderr。可以使用setLog和setLogError方法更改此设置。 示例用法如下： public static void main ( String [] args ) throws Exception { if ( args . length != 1 ) { System . out . println ( \"You must provide 1 argument - the base path for the server to serve from.\" ); System . exit ( 1 ); } TFTPServer ts = new TFTPServer ( new File ( args [ 0 ]), new File ( args [ 0 ]), GET_AND_PUT ); ts . setSocketTimeout ( 2000 ); System . out . println ( \"TFTP Server running. Press enter to stop.\" ); new InputStreamReader ( System . in ). read (); ts . shutdown (); System . out . println ( \"Server shut down.\" ); System . exit ( 0 ); } 代码 /* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.net.tftp ; import java.io.BufferedInputStream ; import java.io.BufferedOutputStream ; import java.io.File ; import java.io.FileInputStream ; import java.io.FileNotFoundException ; import java.io.FileOutputStream ; import java.io.IOException ; import java.io.InputStream ; import java.io.OutputStream ; import java.io.PrintStream ; import java.net.InetAddress ; import java.net.NetworkInterface ; import java.net.SocketTimeoutException ; import java.util.HashSet ; import java.util.Enumeration ; import java.util.Iterator ; import org.apache.commons.net.io.FromNetASCIIOutputStream ; import org.apache.commons.net.io.ToNetASCIIInputStream ; /** * A fully multi-threaded tftp server. Can handle multiple clients at the same time. Implements RFC * 1350 and wrapping block numbers for large file support. * * To launch, just create an instance of the class. An IOException will be thrown if the server * fails to start for reasons such as port in use, port denied, etc. * * To stop, use the shutdown method. * * To check to see if the server is still running (or if it stopped because of an error), call the * isRunning() method. * * By default, events are not logged to stdout/stderr. This can be changed with the * setLog and setLogError methods. * * <p> * Example usage is below: * * <code> * public static void main(String[] args) throws Exception * { * if (args.length != 1) * { * System.out * .println(\"You must provide 1 argument - the base path for the server to serve from.\"); * System.exit(1); * } * * TFTPServer ts = new TFTPServer(new File(args[0]), new File(args[0]), GET_AND_PUT); * ts.setSocketTimeout(2000); * * System.out.println(\"TFTP Server running. Press enter to stop.\"); * new InputStreamReader(System.in).read(); * * ts.shutdown(); * System.out.println(\"Server shut down.\"); * System.exit(0); * } * * </code> * * @since 2.0 */ public class TFTPServer implements Runnable { private static final int DEFAULT_TFTP_PORT = 69 ; public static enum ServerMode { GET_ONLY , PUT_ONLY , GET_AND_PUT ; } private final HashSet < TFTPTransfer > transfers_ = new HashSet < TFTPTransfer >(); private volatile boolean shutdownServer = false ; private TFTP serverTftp_ ; private File serverReadDirectory_ ; private File serverWriteDirectory_ ; private final int port_ ; private final InetAddress laddr_ ; private Exception serverException = null ; private final ServerMode mode_ ; /* /dev/null output stream (default) */ private static final PrintStream nullStream = new PrintStream ( new OutputStream () { @Override public void write ( int b ){} @Override public void write ( byte [] b ) throws IOException {} } ); // don't have access to a logger api, so we will log to these streams, which // by default are set to a no-op logger private PrintStream log_ ; private PrintStream logError_ ; private int maxTimeoutRetries_ = 3 ; private int socketTimeout_ ; private Thread serverThread ; /** * Start a TFTP Server on the default port (69). Gets and Puts occur in the specified * directories. * * The server will start in another thread, allowing this constructor to return immediately. * * If a get or a put comes in with a relative path that tries to get outside of the * serverDirectory, then the get or put will be denied. * * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both. * Modes are defined as int constants in this class. * * @param serverReadDirectory directory for GET requests * @param serverWriteDirectory directory for PUT requests * @param mode A value as specified above. * @throws IOException if the server directory is invalid or does not exist. */ public TFTPServer ( File serverReadDirectory , File serverWriteDirectory , ServerMode mode ) throws IOException { this ( serverReadDirectory , serverWriteDirectory , DEFAULT_TFTP_PORT , mode , null , null ); } /** * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory. * * The server will start in another thread, allowing this constructor to return immediately. * * If a get or a put comes in with a relative path that tries to get outside of the * serverDirectory, then the get or put will be denied. * * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both. * Modes are defined as int constants in this class. * * @param serverReadDirectory directory for GET requests * @param serverWriteDirectory directory for PUT requests * @param port the port to use * @param mode A value as specified above. * @param log Stream to write log message to. If not provided, uses System.out * @param errorLog Stream to write error messages to. If not provided, uses System.err. * @throws IOException if the server directory is invalid or does not exist. */ public TFTPServer ( File serverReadDirectory , File serverWriteDirectory , int port , ServerMode mode , PrintStream log , PrintStream errorLog ) throws IOException { port_ = port ; mode_ = mode ; log_ = ( log == null ? nullStream : log ); logError_ = ( errorLog == null ? nullStream : errorLog ); laddr_ = null ; launch ( serverReadDirectory , serverWriteDirectory ); } /** * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory. * * The server will start in another thread, allowing this constructor to return immediately. * * If a get or a put comes in with a relative path that tries to get outside of the * serverDirectory, then the get or put will be denied. * * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both. * Modes are defined as int constants in this class. * * @param serverReadDirectory directory for GET requests * @param serverWriteDirectory directory for PUT requests * @param port The local port to bind to. * @param localaddr The local address to bind to. * @param mode A value as specified above. * @param log Stream to write log message to. If not provided, uses System.out * @param errorLog Stream to write error messages to. If not provided, uses System.err. * @throws IOException if the server directory is invalid or does not exist. */ public TFTPServer ( File serverReadDirectory , File serverWriteDirectory , int port , InetAddress localaddr , ServerMode mode , PrintStream log , PrintStream errorLog ) throws IOException { port_ = port ; mode_ = mode ; laddr_ = localaddr ; log_ = ( log == null ? nullStream : log ); logError_ = ( errorLog == null ? nullStream : errorLog ); launch ( serverReadDirectory , serverWriteDirectory ); } /** * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory. * * The server will start in another thread, allowing this constructor to return immediately. * * If a get or a put comes in with a relative path that tries to get outside of the * serverDirectory, then the get or put will be denied. * * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both. * Modes are defined as int constants in this class. * * @param serverReadDirectory directory for GET requests * @param serverWriteDirectory directory for PUT requests * @param port the port to use * @param localiface The local network interface to bind to. * The interface's first address wil be used. * @param mode A value as specified above. * @param log Stream to write log message to. If not provided, uses System.out * @param errorLog Stream to write error messages to. If not provided, uses System.err. * @throws IOException if the server directory is invalid or does not exist. */ public TFTPServer ( File serverReadDirectory , File serverWriteDirectory , int port , NetworkInterface localiface , ServerMode mode , PrintStream log , PrintStream errorLog ) throws IOException { mode_ = mode ; port_ = port ; InetAddress iaddr = null ; if ( localiface != null ) { Enumeration < InetAddress > ifaddrs = localiface . getInetAddresses (); if ( ifaddrs != null ) { if ( ifaddrs . hasMoreElements ()) iaddr = ifaddrs . nextElement (); } } log_ = ( log == null ? nullStream : log ); logError_ = ( errorLog == null ? nullStream : errorLog ); laddr_ = iaddr ; launch ( serverReadDirectory , serverWriteDirectory ); } /** * Set the max number of retries in response to a timeout. Default 3. Min 0. * * @param retries number of retries, must be &gt; 0 */ public void setMaxTimeoutRetries ( int retries ) { if ( retries < 0 ) { throw new RuntimeException ( \"Invalid Value\" ); } maxTimeoutRetries_ = retries ; } /** * Get the current value for maxTimeoutRetries * @return the max allowed number of retries */ public int getMaxTimeoutRetries () { return maxTimeoutRetries_ ; } /** * Set the socket timeout in milliseconds used in transfers. Defaults to the value here: * http://commons.apache.org/net/apidocs/org/apache/commons/net/tftp/TFTP.html#DEFAULT_TIMEOUT * (5000 at the time I write this) Min value of 10. * @param timeout the timeout; must be larger than 10 */ public void setSocketTimeout ( int timeout ) { if ( timeout < 10 ) { throw new RuntimeException ( \"Invalid Value\" ); } socketTimeout_ = timeout ; } /** * The current socket timeout used during transfers in milliseconds. * @return the timeout value */ public int getSocketTimeout () { return socketTimeout_ ; } /* * start the server, throw an error if it can't start. */ private void launch ( File serverReadDirectory , File serverWriteDirectory ) throws IOException { log_ . println ( \"Starting TFTP Server on port \" + port_ + \". Read directory: \" + serverReadDirectory + \" Write directory: \" + serverWriteDirectory + \" Server Mode is \" + mode_ ); serverReadDirectory_ = serverReadDirectory . getCanonicalFile (); if (! serverReadDirectory_ . exists () || ! serverReadDirectory . isDirectory ()) { throw new IOException ( \"The server read directory \" + serverReadDirectory_ + \" does not exist\" ); } serverWriteDirectory_ = serverWriteDirectory . getCanonicalFile (); if (! serverWriteDirectory_ . exists () || ! serverWriteDirectory . isDirectory ()) { throw new IOException ( \"The server write directory \" + serverWriteDirectory_ + \" does not exist\" ); } serverTftp_ = new TFTP (); // This is the value used in response to each client. socketTimeout_ = serverTftp_ . getDefaultTimeout (); // we want the server thread to listen forever. serverTftp_ . setDefaultTimeout ( 0 ); if ( laddr_ != null ) { serverTftp_ . open ( port_ , laddr_ ); } else { serverTftp_ . open ( port_ ); } serverThread = new Thread ( this ); serverThread . setDaemon ( true ); serverThread . start (); } @Override protected void finalize () throws Throwable { shutdown (); } /** * check if the server thread is still running. * * @return true if running, false if stopped. * @throws Exception throws the exception that stopped the server if the server is stopped from * an exception. */ public boolean isRunning () throws Exception { if ( shutdownServer && serverException != null ) { throw serverException ; } return ! shutdownServer ; } @Override public void run () { try { while (! shutdownServer ) { TFTPPacket tftpPacket ; tftpPacket = serverTftp_ . receive (); TFTPTransfer tt = new TFTPTransfer ( tftpPacket ); synchronized ( transfers_ ) { transfers_ . add ( tt ); } Thread thread = new Thread ( tt ); thread . setDaemon ( true ); thread . start (); } } catch ( Exception e ) { if (! shutdownServer ) { serverException = e ; logError_ . println ( \"Unexpected Error in TFTP Server - Server shut down! + \" + e ); } } finally { shutdownServer = true ; // set this to true, so the launching thread can check to see if it started. if ( serverTftp_ != null && serverTftp_ . isOpen ()) { serverTftp_ . close (); } } } /** * Stop the tftp server (and any currently running transfers) and release all opened network * resources. */ public void shutdown () { shutdownServer = true ; synchronized ( transfers_ ) { Iterator < TFTPTransfer > it = transfers_ . iterator (); while ( it . hasNext ()) { it . next (). shutdown (); } } try { serverTftp_ . close (); } catch ( RuntimeException e ) { // noop } try { serverThread . join (); } catch ( InterruptedException e ) { // we've done the best we could, return } } /* * An instance of an ongoing transfer. */ private class TFTPTransfer implements Runnable { private final TFTPPacket tftpPacket_ ; private boolean shutdownTransfer = false ; TFTP transferTftp_ = null ; public TFTPTransfer ( TFTPPacket tftpPacket ) { tftpPacket_ = tftpPacket ; } public void shutdown () { shutdownTransfer = true ; try { transferTftp_ . close (); } catch ( RuntimeException e ) { // noop } } @Override public void run () { try { transferTftp_ = newTFTP (); transferTftp_ . beginBufferedOps (); transferTftp_ . setDefaultTimeout ( socketTimeout_ ); transferTftp_ . open (); if ( tftpPacket_ instanceof TFTPReadRequestPacket ) { handleRead ((( TFTPReadRequestPacket ) tftpPacket_ )); } else if ( tftpPacket_ instanceof TFTPWriteRequestPacket ) { handleWrite (( TFTPWriteRequestPacket ) tftpPacket_ ); } else { log_ . println ( \"Unsupported TFTP request (\" + tftpPacket_ + \") - ignored.\" ); } } catch ( Exception e ) { if (! shutdownTransfer ) { logError_ . println ( \"Unexpected Error in during TFTP file transfer. Transfer aborted. \" + e ); } } finally { try { if ( transferTftp_ != null && transferTftp_ . isOpen ()) { transferTftp_ . endBufferedOps (); transferTftp_ . close (); } } catch ( Exception e ) { // noop } synchronized ( transfers_ ) { transfers_ . remove ( this ); } } } /* * Handle a tftp read request. */ private void handleRead ( TFTPReadRequestPacket trrp ) throws IOException , TFTPPacketException { InputStream is = null ; try { if ( mode_ == ServerMode . PUT_ONLY ) { transferTftp_ . bufferedSend ( new TFTPErrorPacket ( trrp . getAddress (), trrp . getPort (), TFTPErrorPacket . ILLEGAL_OPERATION , \"Read not allowed by server.\" )); return ; } try { is = new BufferedInputStream ( new FileInputStream ( buildSafeFile ( serverReadDirectory_ , trrp . getFilename (), false ))); } catch ( FileNotFoundException e ) { transferTftp_ . bufferedSend ( new TFTPErrorPacket ( trrp . getAddress (), trrp . getPort (), TFTPErrorPacket . FILE_NOT_FOUND , e . getMessage ())); return ; } catch ( Exception e ) { transferTftp_ . bufferedSend ( new TFTPErrorPacket ( trrp . getAddress (), trrp . getPort (), TFTPErrorPacket . UNDEFINED , e . getMessage ())); return ; } if ( trrp . getMode () == TFTP . NETASCII_MODE ) { is = new ToNetASCIIInputStream ( is ); } byte [] temp = new byte [ TFTPDataPacket . MAX_DATA_LENGTH ]; TFTPPacket answer ; int block = 1 ; boolean sendNext = true ; int readLength = TFTPDataPacket . MAX_DATA_LENGTH ; TFTPDataPacket lastSentData = null ; // We are reading a file, so when we read less than the // requested bytes, we know that we are at the end of the file. while ( readLength == TFTPDataPacket . MAX_DATA_LENGTH && ! shutdownTransfer ) { if ( sendNext ) { readLength = is . read ( temp ); if ( readLength == - 1 ) { readLength = 0 ; } lastSentData = new TFTPDataPacket ( trrp . getAddress (), trrp . getPort (), block , temp , 0 , readLength ); sendData ( transferTftp_ , lastSentData ); // send the data } answer = null ; int timeoutCount = 0 ; while (! shutdownTransfer && ( answer == null || ! answer . getAddress (). equals ( trrp . getAddress ()) || answer . getPort () != trrp . getPort ())) { // listen for an answer. if ( answer != null ) { // The answer that we got didn't come from the // expected source, fire back an error, and continue // listening. log_ . println ( \"TFTP Server ignoring message from unexpected source.\" ); transferTftp_ . bufferedSend ( new TFTPErrorPacket ( answer . getAddress (), answer . getPort (), TFTPErrorPacket . UNKNOWN_TID , \"Unexpected Host or Port\" )); } try { answer = transferTftp_ . bufferedReceive (); } catch ( SocketTimeoutException e ) { if ( timeoutCount >= maxTimeoutRetries_ ) { throw e ; } // didn't get an ack for this data. need to resend // it. timeoutCount ++; transferTftp_ . bufferedSend ( lastSentData ); continue ; } } if ( answer == null || !( answer instanceof TFTPAckPacket )) { if (! shutdownTransfer ) { logError_ . println ( \"Unexpected response from tftp client during transfer (\" + answer + \"). Transfer aborted.\" ); } break ; } else { // once we get here, we know we have an answer packet // from the correct host. TFTPAckPacket ack = ( TFTPAckPacket ) answer ; if ( ack . getBlockNumber () != block ) { /* * The origional tftp spec would have called on us to resend the * previous data here, however, that causes the SAS Syndrome. * http://www.faqs.org/rfcs/rfc1123.html section 4.2.3.1 The modified * spec says that we ignore a duplicate ack. If the packet was really * lost, we will time out on receive, and resend the previous data at * that point. */ sendNext = false ; } else { // send the next block block ++; if ( block > 65535 ) { // wrap the block number block = 0 ; } sendNext = true ; } } } } finally { try { if ( is != null ) { is . close (); } } catch ( IOException e ) { // noop } } } /* * handle a tftp write request. */ private void handleWrite ( TFTPWriteRequestPacket twrp ) throws IOException , TFTPPacketException { OutputStream bos = null ; try { if ( mode_ == ServerMode . GET_ONLY ) { transferTftp_ . bufferedSend ( new TFTPErrorPacket ( twrp . getAddress (), twrp . getPort (), TFTPErrorPacket . ILLEGAL_OPERATION , \"Write not allowed by server.\" )); return ; } int lastBlock = 0 ; String fileName = twrp . getFilename (); try { File temp = buildSafeFile ( serverWriteDirectory_ , fileName , true ); if ( temp . exists ()) { transferTftp_ . bufferedSend ( new TFTPErrorPacket ( twrp . getAddress (), twrp . getPort (), TFTPErrorPacket . FILE_EXISTS , \"File already exists\" )); return ; } bos = new BufferedOutputStream ( new FileOutputStream ( temp )); if ( twrp . getMode () == TFTP . NETASCII_MODE ) { bos = new FromNetASCIIOutputStream ( bos ); } } catch ( Exception e ) { transferTftp_ . bufferedSend ( new TFTPErrorPacket ( twrp . getAddress (), twrp . getPort (), TFTPErrorPacket . UNDEFINED , e . getMessage ())); return ; } TFTPAckPacket lastSentAck = new TFTPAckPacket ( twrp . getAddress (), twrp . getPort (), 0 ); sendData ( transferTftp_ , lastSentAck ); // send the data while ( true ) { // get the response - ensure it is from the right place. TFTPPacket dataPacket = null ; int timeoutCount = 0 ; while (! shutdownTransfer && ( dataPacket == null || ! dataPacket . getAddress (). equals ( twrp . getAddress ()) || dataPacket . getPort () != twrp . getPort ())) { // listen for an answer. if ( dataPacket != null ) { // The data that we got didn't come from the // expected source, fire back an error, and continue // listening. log_ . println ( \"TFTP Server ignoring message from unexpected source.\" ); transferTftp_ . bufferedSend ( new TFTPErrorPacket ( dataPacket . getAddress (), dataPacket . getPort (), TFTPErrorPacket . UNKNOWN_TID , \"Unexpected Host or Port\" )); } try { dataPacket = transferTftp_ . bufferedReceive (); } catch ( SocketTimeoutException e ) { if ( timeoutCount >= maxTimeoutRetries_ ) { throw e ; } // It didn't get our ack. Resend it. transferTftp_ . bufferedSend ( lastSentAck ); timeoutCount ++; continue ; } } if ( dataPacket != null && dataPacket instanceof TFTPWriteRequestPacket ) { // it must have missed our initial ack. Send another. lastSentAck = new TFTPAckPacket ( twrp . getAddress (), twrp . getPort (), 0 ); transferTftp_ . bufferedSend ( lastSentAck ); } else if ( dataPacket == null || !( dataPacket instanceof TFTPDataPacket )) { if (! shutdownTransfer ) { logError_ . println ( \"Unexpected response from tftp client during transfer (\" + dataPacket + \"). Transfer aborted.\" ); } break ; } else { int block = (( TFTPDataPacket ) dataPacket ). getBlockNumber (); byte [] data = (( TFTPDataPacket ) dataPacket ). getData (); int dataLength = (( TFTPDataPacket ) dataPacket ). getDataLength (); int dataOffset = (( TFTPDataPacket ) dataPacket ). getDataOffset (); if ( block > lastBlock || ( lastBlock == 65535 && block == 0 )) { // it might resend a data block if it missed our ack // - don't rewrite the block. bos . write ( data , dataOffset , dataLength ); lastBlock = block ; } lastSentAck = new TFTPAckPacket ( twrp . getAddress (), twrp . getPort (), block ); sendData ( transferTftp_ , lastSentAck ); // send the data if ( dataLength < TFTPDataPacket . MAX_DATA_LENGTH ) { // end of stream signal - The tranfer is complete. bos . close (); // But my ack may be lost - so listen to see if I // need to resend the ack. for ( int i = 0 ; i < maxTimeoutRetries_ ; i ++) { try { dataPacket = transferTftp_ . bufferedReceive (); } catch ( SocketTimeoutException e ) { // this is the expected route - the client // shouldn't be sending any more packets. break ; } if ( dataPacket != null && (! dataPacket . getAddress (). equals ( twrp . getAddress ()) || dataPacket . getPort () != twrp . getPort ())) { // make sure it was from the right client... transferTftp_ . bufferedSend ( new TFTPErrorPacket ( dataPacket . getAddress (), dataPacket . getPort (), TFTPErrorPacket . UNKNOWN_TID , \"Unexpected Host or Port\" )); } else { // This means they sent us the last // datapacket again, must have missed our // ack. resend it. transferTftp_ . bufferedSend ( lastSentAck ); } } // all done. break ; } } } } finally { if ( bos != null ) { bos . close (); } } } /* * Utility method to make sure that paths provided by tftp clients do not get outside of the * serverRoot directory. */ private File buildSafeFile ( File serverDirectory , String fileName , boolean createSubDirs ) throws IOException { File temp = new File ( serverDirectory , fileName ); temp = temp . getCanonicalFile (); if (! isSubdirectoryOf ( serverDirectory , temp )) { throw new IOException ( \"Cannot access files outside of tftp server root.\" ); } // ensure directory exists (if requested) if ( createSubDirs ) { createDirectory ( temp . getParentFile ()); } return temp ; } /* * recursively create subdirectories */ private void createDirectory ( File file ) throws IOException { File parent = file . getParentFile (); if ( parent == null ) { throw new IOException ( \"Unexpected error creating requested directory\" ); } if (! parent . exists ()) { // recurse... createDirectory ( parent ); } if ( parent . isDirectory ()) { if ( file . isDirectory ()) { return ; } boolean result = file . mkdir (); if (! result ) { throw new IOException ( \"Couldn't create requested directory\" ); } } else { throw new IOException ( \"Invalid directory path - file in the way of requested folder\" ); } } /* * recursively check to see if one directory is a parent of another. */ private boolean isSubdirectoryOf ( File parent , File child ) { File childsParent = child . getParentFile (); if ( childsParent == null ) { return false ; } if ( childsParent . equals ( parent )) { return true ; } else { return isSubdirectoryOf ( parent , childsParent ); } } } /** * Set the stream object to log debug / informational messages. By default, this is a no-op * * @param log the stream to use for logging */ public void setLog ( PrintStream log ) { this . log_ = log ; } /** * Set the stream object to log error messsages. By default, this is a no-op * * @param logError the stream to use for logging errors */ public void setLogError ( PrintStream logError ) { this . logError_ = logError ; } /* * Allow test code to customise the TFTP instance */ TFTP newTFTP () { return new TFTP (); } /* * Also allow customisation of sending data/ack so can generate errors if needed */ void sendData ( TFTP tftp , TFTPPacket data ) throws IOException { tftp . bufferedSend ( data ); } }","tags":"Coding","loc":"articles/2019/coding-AJavaTFTPServer.html","title":"A Java TFTP Server"},{"url":"articles/2019/coding-Java代码优化35点总结.html","text":"前言 代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。 代码优化的目标是： 1、减小代码的体积 2、提高代码运行的效率 代码优化细节 1、尽量指定类、方法的final修饰符 带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。 2、尽量重用对象 特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。 3、尽可能使用局部变量 调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 4、及时关闭流 Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。 5、尽量减少对变量的重复计算 明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作： for ( int i = 0 ; i < list . size (); i ++) {...} 建议替换为： for ( int i = 0 , int length = list . size (); i < length ; i ++) {...} 这样，在list.size()很大的时候，就减少了很多的消耗 6、尽量采用懒加载的策略，即在需要的时候才创建 例如： String str = \"aaa\" ; if ( i == 1 ) { list . add ( str ); } 建议替换为： if ( i == 1 ) { String str = \"aaa\" ; list . add ( str ); } 7、慎用异常 异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 8、不要在循环中使用try...catch...，应该把其放在最外层 除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了 9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度 比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例： StringBuilder () // 默认分配16个字符的空间 StringBuilder ( int size ) // 默认分配size个字符的空间 StringBuilder ( String str ) // 默认分配16个字符+str.length()个字符空间 可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中----这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么： 在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间 把原来的4096个字符拷贝到新的的字符数组中去 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 10、当复制大量数据时，使用System.arraycopy()命令 11、乘法和除法使用移位操作 例如： for ( val = 0 ; val < 100000 ; val += 5 ) { a = val * 8 ; b = val / 2 ; } 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： for ( val = 0 ; val < 100000 ; val += 5 ) { a = val << 3 ; b = val >> 1 ; } 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 12、循环内不要不断创建对象引用 例如： for ( int i = 1 ; i <= count ; i ++) { Object obj = new Object (); } 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为： Object obj = null ; for ( int i = 0 ; i <= count ; i ++){ obj = new Object ();} 这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。 13、基于效率和类型检查的考虑，应该尽可能使用array 无法确定数组大小时才使用ArrayList 14、尽量使用HashMap、ArrayList、StringBuilder 除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销 15、不要将数组声明为public static final 因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变 16、尽量在合适的场合使用单例 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： 控制资源的使用，通过线程同步来控制资源的并发访问 控制实例的产生，以达到节约资源的目的 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 17、尽量避免随意使用静态变量 要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如： public class A { private static B b = new B (); } 此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止 18、及时清除不再需要的会话 为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。 19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历 这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断： if ( list instanceof RandomAccess ) { for ( int i = 0 ; i < list . size (); i ++){} } else { Iterator <?> iterator = list . iterable (); while ( iterator . hasNext ()){ iterator . next ()} } foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句\"反过来，如果是顺序访问的，则使用Iterator会效率更高\"的意思就是顺序访问的那些类实例，使用foreach循环去遍历。 20、使用同步代码块替代同步方法 这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。 21、将常量声明为static final，并以大写命名 这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量 22、不要创建一些不使用的对象，不要导入一些不使用的类 这毫无意义，如果代码中出现\"The value of the local variable i is not used\"、\"The import java.util is never used\"，那么请删除这些无用的内容 23、程序运行过程中避免使用反射 关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存----用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。 24、使用数据库连接池和线程池 这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程 25、使用带缓冲的输入输出流进行IO操作 带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率 26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList 这个，理解ArrayList和LinkedList的原理就知道了 27、不要让public方法中有太多的形参 public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处： 违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合 参数太多势必导致方法调用的出错概率增加 至于这个\"太多\"指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参 28、字符串变量和字符串常量equals的时候将字符串常量写在前面 这是一个比较常见的小技巧了，如果有以下代码： String str = \"123\" ; if ( str . equals ( \"123\" )){ ... } 建议修改为： String str = \"123\" ; if ( \"123\" . equals ( str )) { ... } 这么做主要是可以避免空指针异常 29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者 平时有人问， if (i == 1) 和 if (1== i) 有没有区别，这就要从C/C++讲起。 在C/C++中， if (i == 1) 判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码： int i = 2 ; if ( i == 1 ) { ... } else { ... } C/C++判断\"i==1\"不成立，所以以0表示，即false。但是如果： int i = 2 ; if ( i = 1 ){ ...} else { ...} 万一程序员一个不小心，把\"if (i == 1)\"写成\"if (i = 1)\"，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为： int i = 2 ; if ( 1 == i ){ ...} else { ...} 这样，即使开发者不小心写成了 1 = i ，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。 但是，在Java中，C/C++这种 if (i = 1) 的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错\"Type mismatch: cannot convert from int to boolean\"。但是，尽管Java的 if (i == 1) 和 if (1 == i) 在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。 30、不要对数组使用toString()方法 看一下对数组使用toString()打印出来的是什么： public static void main ( String [] args ) { int [] is = new int []{ 1 , 2 , 3 }; System . out . println ( is . toString ()); } 结果是： [ I @ 18 a992f 本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections 重写了Object的toString()方法。 31、不要对超出范围的基本数据类型做向下强制转型 这绝不会得到想要的结果： public static void main ( String [] args ) { long l = 12345678901234L ; int i = ( int ) l ; System . out . println ( i ); } 我们可能期望得到其中的某几位，但是结果却是： 1942892530 解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是： 0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010 一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是： 0111 0011 1100 1110 0010 1111 1111 0010 这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论： 整型默认的数据类型是int; long l = 12345678901234L ，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成 float f = 3.5f 接下来再写一句 int ii = l + i; 会报错，因为long + int是一个long，不能赋值给int 32、公用的集合类中不使用的数据一定要及时remove掉 如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+\"\"最慢 把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+\"\"三种方式，三种方式的效率如何，看一个测试： public static void main ( String [] args ) { int loopTime = 50000 ; Integer i = 0 ; long startTime = System . currentTimeMillis (); for ( int j = 0 ; j < loopTime ; j ++) { String str = String . valueOf ( i ); } System . out . println ( \"String.valueOf()：\" + ( System . currentTimeMillis () - startTime ) + \"ms\" ); startTime = System . currentTimeMillis (); for ( int j = 0 ; j < loopTime ; j ++) { String str = i . toString (); } System . out . println ( \"Integer.toString()：\" + ( System . currentTimeMillis () - startTime ) + \"ms\" ); startTime = System . currentTimeMillis (); for ( int j = 0 ; j < loopTime ; j ++) { String str = i + \"\" ; } System . out . println ( \"i + \"\"：\" + ( System . currentTimeMillis () - startTime ) + \"ms\" ); } 运行结果为： String . valueOf () ： 11 msInteger . toString () ： 5 msi + \"\" ： 25 ms 所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单： String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断 Integer.toString()方法就不说了，直接调用了 i + \"\"底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串 三者对比下来，明显是2最快、1次之、3最慢 34、使用最有效率的方式去遍历Map 遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是： public static void main ( String [] args ) { HashMap < String , String > hm = new HashMap < String , String >(); hm . put ( \"111\" , \"222\" ); Set < Map . Entry < String , String >> entrySet = hm . entrySet (); Iterator < Map . Entry < String , String >> iter = entrySet . iterator (); while ( iter . hasNext ()) { Map . Entry < String , String > entry = iter . next (); System . out . println ( entry . getKey () + \" \" + entry . getValue ()); } } 如果你只是想遍历一下这个Map的key值，那用 Set<String> keySet = hm.keySet(); 会比较合适一些 35、对资源的close()建议分开操作 意思是，比如我有这么一段代码： try{ XXX.close(); YYY.close(); }catch (Exception e) { ... } 建议修改为： try { XXX . close ();} catch ( Exception e ){ ...} try { YYY . close ();} catch ( Exception e ){ ...} 虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉。","tags":"Coding","loc":"articles/2019/coding-Java代码优化35点总结.html","title":"Java代码优化35点总结"},{"url":"articles/2019/notes-人之一生.html","text":"热爱生命 我不去想， 是否能够成功 ， 既然选择了远方 ， 便只顾风雨兼程。 我不去想， 能否赢得爱情 ， 既然钟情于玫瑰 ， 就勇敢地吐露真诚 。 我不去想， 身后会不会袭来寒风冷雨 ， 既然目标是地平线， 留给世界的只能是背影 。 我不去想， 未来是平坦还是泥泞 ， 只要热爱生命 ， 一切，都在意料之中。 决心 人之一生，总会有许多困惑不已、纠缠不清的琐事，难免受其影响，绝不为其左右。 此时所需的就是断然的取舍与明智的抉择，唯一会限制我们的，是我们自己的决心。 延续 万物善变，人生泛滥的是那些冲动和急躁：即兴的热情、肤浅的思考、仓促的决定、敷衍的搪塞和最终的草草了事； 而珍贵的是生命中那些经久和坚持，一种信仰，一段情感，一个习惯。一句独白自视为约定，一段感情权当作余生。 动力 如果说不清追逐的动力源于何处，就至少要让优秀成为自己的习惯，要乐观阳光，要知道自己身在何处，路在何方。 初心 愿我们在心底埋下的勇气、乐观和向善的种子，最后都成长为自己一直所追寻的最喜欢的样子。","tags":"Notes","loc":"articles/2019/notes-人之一生.html","title":"人之一生"},{"url":"articles/2018/blog-JQCloud.html","text":"因为博客需要，发现了一个生成美化简约风格的标签云的JQuery插件。 官网地址： http://mistic100.github.io/jQCloud/index.html 使用方法很简单，可以把JS和CSS文件下载到本地，也可以直接通过Script标签src=\"\"的方法在线引用。 具体的使用方法官网都能查到。 贴出自己微博使用JQCloud的前端代码： < script src = \"{{ SITEURL }}/theme/jqcloud.js\" ></ script > < link href = \"{{ SITEURL }}/theme/jqcloud.css\" rel = \"stylesheet\" > < script > var words = []; { % for tag , articles in tags | sort % } words . push ({ text : \"{{tag}}\" , weight : Math . random (), link : '{{ SITEURL }}/{{ tag.url }}' }); { % endfor % } { % for category , articles in categories % } words . push ({ text : \"{{category}}\" , weight : Math . random (), link : '{{ SITEURL }}/{{ category.url }}' }); { % endfor % } $ ( function () { $ ( \"#tagcloud\" ). jQCloud ( words , { autoResize : true }); }); </ script > < div id = \"tagcloud\" style = \"width: 80%; height: 450px; align-self: center;\" ></ div > 需要注意的是要包含标签云的div模块需要显示指定width和height，否则需要在JavaScript中进行相关设置。 踩坑1：因为要基于JQuery，注意引用的JQuery库可用。由于之前引用的是外网谷歌的库，国内被墙导致标签云一直没有刷出来，后来换成了bootcdn的JQuery库就成功了： < script src = \"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\" ></ script >","tags":"Blog","loc":"articles/2018/blog-JQCloud.html","title":"JQCloud: 一个前端生成美化标签云的简单JQuery插件"},{"url":"articles/2018/blog-使用Pelican在Github和Coding同步托管博客.html","text":"介绍： Github Pages 禁用了百度爬虫，因此百度搜索引擎经常抓取不到在Github上托管的博客链接。本文介绍一种可行的解决方法： - 注册Coding用来托管一份和Github上一样的博客仓库专门服务国内的索引 - 配置DNS解析，将国内的线路解析到Coding，国外的线路解析到Github - 配置Pelican，支持一键将同一份本地博客仓库同时发布到Github和Coding ​ 一、 《Pelican＋Github博客搭建详细教程》 按照标题链接给出的教程先搭建出一个基于Github托管的博客系统。接下来将说明如何将博客同步到Coding。 二、在Coding创建一个新的项目 在 Coding首页 进行注册并登陆，创建项目的方法与Github类似，不同之处在于coding新建的公开项目名和用户名相同，而不像Github那样是<用户名>.github.io。创建完成后，生成的新的项目链接应该类似于： https://coding.net/<usrname>/<username>.git 。 将本地SSH公钥拷贝到coding。操作同样与Github类似。由于本地已经为Github生成了一个公钥，这里只用cd进入~/.ssh文件夹查看一个名为 id_rsa.pub 文件的内容，类似于如下。我们只拷贝 邮箱之前 的所有内容到coding的公钥管理页面。 ssh-rsa AAAAfafjIJGOF+FDA。。(省略)。。Ksap Heriam@users.noreply.github.com 三、将仓库拷贝到Coding 进入Pelican的output目录下的本地博客仓库，打开.git/config，修改远程仓库，将 origin 改为 github，并添加 coding： [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote \"github\"] url = git@github.com:Heriam/heriam.github.io.git fetch = +refs/heads/*:refs/remotes/github/* [remote \"coding\"] url = git@git.coding.net:Heriam/heriam.git fetch = +refs/heads/*:refs/remotes/coding/* [branch \"master\"] remote = origin merge = refs/heads/master 2. 然后将仓库 push 到 Coding上，在Coding新建一个 coding-pages 分支： git push -u coding master:coding-pages 3. 这时登录Coding就可以看到博客内容已经被拷贝到coding-pages分支。 四、配置域名 登录到网站的域名解析管理页面（我用的是DNSPOD，后来转向Cloudxns），然后添加两条域名解析记录： @ CNAME 国内 coding.me www CNAME 国内 coding.me 在Coding 上\"项目管理\"中找到\"自定义域名／Pages\"，添加要绑定的域名，比如我是 hao-jiang.com和www.hao-jiang.com。注意这些域名也就是我们刚刚在dnspod中设置的解析域名。 五、配置Pelican实现同步提交 设置一键上传：（如有疑问参见 《Pelican＋Github博客搭建详细教程》 第三部分第4点）打开根目录下的Makefile文件，修改以下三个地方： - OUTPUTDIR OUTPUTDIR = $( BASEDIR ) /output/<username>.github.io #本地博客仓库路径 - publish publish : $( PELICAN ) $( INPUTDIR ) -o $( OUTPUTDIR ) -s $( CONFFILE ) $( PELICANOPTS ) - github: publish github : publish cd $ ( OUTPUTDIR ) ; git add . ; git commit - am '<添加自己的备注>' ; git push github master : master ; git push coding master : coding - pages 这样 ，通过 make github 命令就能一键发布博客更新到Github和Coding了。","tags":"Blog","loc":"articles/2018/blog-使用Pelican在Github和Coding同步托管博客.html","title":"使用Pelican在Github(国外)和Coding(国内)同步托管博客"},{"url":"articles/2018/blog-使用Pelican基于GithubPages搭建博客教程.html","text":"操作系统： Mac OS / Linux 工具集： 1.Pelican——基于Python的静态网页生成器 2.马克飞象——Evernote出的Markdown文本编辑器 3.GoDaddy——域名供应商 4.DNSPod——提供免费域名解析注册服务 5.Github Pages——Github为每个注册用户提供300M的站点空间 6.Python——Pelican工具需要Python运行环境 7.Google Analytics——谷歌站点数据监测分析工具 8.Google Custom Search——谷歌自定义搜索引擎可用作站内搜索工具 9.Google Webmasters——谷歌站长工具 10.Disqus——用来提供博客评论功能 11.Sitemap——站点地图，供谷歌，百度等搜索引擎收录 12.七牛云存储——静态资源管理，上传自动生成网盘直链 最终效果展示： 欢迎访问我的博客 ：http://www.hao-jiang.com 一、使用Github Pages创建个人博客页面 Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。GitHub可以托管各种git库的站点。通过GitHub Pages生成的静态站点，可以免费托管、自定义主题、并且自制网页界面。 ​ 1.首先到Github进行账号注册： https://github.com/ 。 2.注册后登录Github，右上角点击\"Creat a new repo\"，跳转到新页面后填写相关内容，注意版本库名使用'username.github.io'的格式，这里将username替换成自己的用户名即可。 3.设置和选择好页面模板后就可以生成然后发布新网页了。 4.创建SSH密钥并上传到Github。 ​ ​ *以上内容都很简单，有问题可以参照： 关于Github注册登录： 通过GitHub创建个人技术博客图文详解1 关于Github页面生成： 通过GitHub创建个人技术博客图文详解2 关于SSH认证： Windows/Mac下使用SSH密钥连接Github 官方文档： Github官方文档在这里 二、安装Python、Pelican和Markdown Pelican是一套开源的使用Python编写的博客静态生成, 可以添加文章和和创建页面, 可以使用MarkDown reStructuredText 和 AsiiDoc 的格式来抒写, 同时使用 Disqus评论系统, 支持 RSS和Atom输出, 插件, 主题, 代码高亮等功能, 采用Jajin2模板引擎, 可以很容易的更改模板。 ​ 1.安装Python。最新的Mac OS 一般都自带Python环境。在终端输入\"python\"即可确认Python版本。如有需要可以到官网安装：http://www.python.org/。 ​ 2.安装Pelican。可以从github克隆最新的代码安装, 并且建议在virtualenv下使用。首先建立 virtualenv（Python虚拟环境）: virtualenv pelican # 创建 cd pelican sh bin/activate # 激活虚拟环境 从github克隆最新代码安装Pelican： git clone git://github.com/getpelican/pelican.git # 下载代码 cd pelican python setup.py install 3.安装Markdown: pip install markdown 三、创建博客骨架 接下来将通过初始化Pelican设置来生成一个基本的博客框架。 ​ 1.搭建博客目录： mkdir blog cd blog pelican-quickstart 2.根据提示一步步输入相应的配置项，不知道如何设置的接受默认即可，后续可以通过编辑pelicanconf.py文件更改配置。完成后将会在根目录生成以下文件： . |-- content # 所有文章放于此目录 │ └── (pages) # 存放手工创建的静态页面 |-- develop_server.sh # 用于开启测试服务器 |-- Makefile # 方便管理博客的Makefile |-- output # 静态生成文件 |-- pelicanconf.py # 配置文件 |-- publishconf.py # 配置文件 3.进入output文件夹，把自己刚刚建好的username.github.io版本库clone下来，注意这里以及后文中的username要替换成自己的Github用户名： cd output git clone https://github.com/username/username.github.io.git 4.设置一键上传部署到Github。打开根目录下的Makefile文件，修改以下三个地方： OUTPUTDIR = $( BASEDIR ) /output/username.github.io publish: $( PELICAN ) $( INPUTDIR ) -o $( OUTPUTDIR ) -s $( CONFFILE ) $( PELICANOPTS ) github: publish cd OUTPUTDIR ; git add . ; git commit -am 'your comments' ; git push 5.设置完后，以后写完文章就可以通过在blog根目录下执行\"make github\"进行一键部署了。 四、通过Markdown试写博文并上传Github发布 Markdown是当下非常流行的一种文本编辑语法，支持HTML转换，书写博文排版也方便快捷。 ​ 1.写一篇文章：用 马克飞象 编辑器用Markdown语法来写一篇文章保存为.md格式放在content目录下。写完后，执行以下命令，即可在本机http://127.0.0.1:8000看到效果。 make publish make serve 2.创建一个页面：这里以创建 About页面为例。在content目录创建pages子目录： mkdir content/pages *然后创建About.md并填入下面内容： title : About Me date : 2013 - 04 - 18 About me content *注意上面title和date是.md文件的重要参数，需要写在文档开头。比如： Title : Pelican + Github Date : 2014 - 10 - 07 22 : 20 Modified : 2014 - 10 - 07 23 : 04 Tags : python , pelican Slug : build - blog - system - by - pelican Authors : Joey Huang Summary : blablablablablablablabla ... Status : draft 相关介绍请参见官方文档：http://pelican-zh.readthedocs.org/en/latest/zh-cn/ 。完成后同样可以在本机http://127.0.0.1:8000看效果。 ​ 3.创建导航目录项：Menu Item设置。在你的博客中，可设置相应的菜单项，菜单项是通过pelicanconf.py设置的，具体如下所示： MENUITEMS = ((\"ITEM1\",\"http://github.com\"), (\"ITEM2\",URL), ......) 五、安装主题 这里以主题bootstrap2为例，同样还在blog目录下： git clone https://github.com/getpelican/pelican-themes.git cd pelican-themes pelican-themes -i bootstrap2 对应在在pelicanconf.py中添加主题选择条目： THEME = 'bootstrap2' 六、安装第三方评论系统Disqus 在Disqus上申请一个站点，记住shortname。 在pelicanconf.py添加： DISQUS_SITENAME = Shortname 七、添加Google Analytics 去Google Analytics申请账号并通过验证，记下跟踪ID（Track ID）， 在pelicanconf.py添加： GOOGLE_ANALYTICS = '跟踪ID' 八、添加Google Webmasters和百度站长收录 为了让博客被Google更好的收录，比如手动让Googlebot抓取、提交Robots、更新Sitemap等等。 ​ 1.在Google Webmasters上注册并通过验证。 ​ 2.添加sitemap插件。还是到/blog目录下执行： cd ~/blog git clone git://github.com/getpelican/pelican-plugins.git *然后在pelicanconf.py里配置如下： PLUGIN_PATH = u\"pelican-plugins\" PLUGINS = [\"sitemap\"] SITEMAP = { \"format\": \"xml\", \"priorities\": { \"articles\": 0.7, \"indexes\": 0.5, \"pages\": 0.3, }, \"changefreqs\": { \"articles\": \"monthly\", \"indexes\": \"daily\", \"pages\": \"monthly\", } } 3.将make github命令后在output目录下生成的sitemap文件上传到Google Webmasters。 ​ 4.对于百度。它是宣称支持sitemap的，但是网上相关问题一大堆，要么格式不对要么就是抓取失败，要么突然不开放支持。在几次尝试失败以后，我是通过添加JavaScript代码来自动推送网站链接的。具体是在主题模板（base.html）面最后添加代码： <script> (function(){ var bp = document.createElement('script'); bp.src = '//push.zhanzhang.baidu.com/push.js'; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); </script> *我还是比较推崇这种方法的，因为比sitemap方法被抓取收录的时间短很多。谷歌的sitemap是xml格式。 九、添加谷歌／百度站内搜索 谷歌站内搜索 1.修改主题。找到这个主题的templates文件夹中的base.html，在 <div class=\"nav-collapse\"> 的最后，添加以下内容： <form class= \"navbar-search pull-right\" action= \"/search.html\" > <input type= \"text\" class= \"search-query\" placeholder= \"Search\" name= \"q\" id= \"s\" > </form> 2.创建search.html。之后，在output目录下，新建一个名为search.html的文件，写入下面的内容，其中需要你自己修改的是google站内搜索的ID号，需要自己在 google站内搜索 的网站上自己申请。 <html lang= \"zh_CN\" > <head> <meta charset= \"utf-8\" > <title> 站内搜索 </title> </head> <body> <style> #search-box { position: relative; width: 50%; margin: 0; padding: 1em; } #search-form { height: 30px; border: 1px solid #999; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; background-color: #fff; overflow: hidden; } #search-text { font-size: 14px; color: #ddd; border-width: 0; background: transparent; } #search-box input[type=\"text\"] { width: 90%; padding: 4px 0 12px 1em; color: #333; outline: none; } </style> <div id= 'search-box' > <form action= '/search.html' id= 'search-form' method= 'get' target= '_top' > <input id= 'search-text' name= 'q' placeholder= 'Search' type= 'text' /> </form> </div> <div id= \"cse\" style= \"width: 100%;\" > Loading </div> <script src= \"http://www.google.com/jsapi\" type= \"text/javascript\" ></script> <script type= \"text/javascript\" > google.load('search', '1', {language : 'zh-CN', style : google.loader.themes.V2_DEFAULT}); google.setOnLoadCallback(function() { var customSearchOptions = {}; var customSearchControl = new google.search.CustomSearchControl( '012191777864628038963:********** <!写入你申请的google站内搜索的ID号> ）', customSearchOptions); customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET); var options = new google.search.DrawOptions(); options.enableSearchResultsOnly(); customSearchControl.draw('cse', options); function parseParamsFromUrl() { var params = {}; var parts = window.location.search.substr(1).split('\\x26'); for (var i = 0; i < parts.length ; i++) { var keyValuePair = parts[i].split('='); var key = decodeURIComponent(keyValuePair[0]); params[key] = keyValuePair[1] ? decodeURIComponent(keyValuePair[1].replace(/\\+/g, ' ')) : keyValuePair[1]; } return params; } var urlParams = parseParamsFromUrl(); var queryParamName = \"q\" ; if (urlParams[queryParamName]) { customSearchControl.execute(urlParams[queryParamName]); } }, true); </script > </body> </html> 3.将GOOGLE_CUSTOM_SEARCH_SIDEBAR = \"001578481551708017171:axpo6yvtdyg\" 添加到pelicanconf.py文件。注意, 引号里的那一串字符是之前申请的自定义搜索引擎的id。 4.最后发布后就可以看到搜索框了。 ​ 百度站内搜索 1.在百度站长平台中注册一个账号，之后添加网站，按照提示验证网站。之后左侧 其他工具 中找到 站内搜索 ，按照提示填写基本信息，选择搜索框样式，之后点击 查看代码 ，复制其中内容，留用。 2.同样在base.html的这个 <div class=\"nav-collapse\"> 的最后，新建一个 div ，刚才注册最后复制的代码粘贴到这个 div 中： <div class= \"navbar-search pull-right\" > <script> <!略> </script> </div> 3.发布验证。 十、添加Tags侧边栏 在其他一些pelican主题中，看到有标签云，想到Tags的链接可能比Categories的链接更有用，通过更改主题，添加了侧栏中红框内的Tags链接框。 ​ 1.还是找到base.html，找到categories部分： {% if categories %} <div class= \"well\" style= \"padding: 8px 0; background-color: #FBFBFB;\" > <ul class= \"nav nav-list\" > <li class= \"nav-header\" > Categories </li> {% for cat , null in categories %} <li><a href= \" {{ SITEURL }} / {{ cat.url }} \" > {{ cat }} </a></li> {% endfor %} </ul> </div> {% endif %} 2.在这段后面添加： {% if tags %} <div class= \"well\" style= \"padding: 8px 0; background-color: #FBFBFB;\" > <ul class= \"nav nav-list\" > <li class= \"nav-header\" > Tags </li> {% for name , tag in tags %} <li><a href= \" {{ SITEURL }} / {{ name.url }} \" > {{ name }} </a></li> {% endfor %} </ul> </div> {% endif %} 3.保存，重新发布网页验证。 十一、插入视频 其实很简单, 只需要把html代码放进markdown源文件就行了! 而视频的html代码在视频网站上一般都会提供。复制下来放进源文件即可。 十二、拷贝静态文件 如果我们定义静态的文件，该如何将它在每次生成的时候拷贝到 output 目录呢，我们以网站logo图片sitelogo.ico为例，在我们的 content/extra 下放置网站的静态资源文件：sitelogo.ico，在pelicanconf.py更改或添加 FILES_TO_COPY项： FILES_TO_COPY = ( (\"extra/sitelogo.ico\", \"sitelogo.ico\"), ) 这样在每次生成html的时候都会把 content/extra下的 sitelogo.ico 拷贝到 output目录下。 十三、资源目录管理 使用目录名作为文章的分类名 USE_FOLDER_AS_CATEGORY = True 使用文件名作为文章或页面的 slug（url） FILENAME_METADATA = '(?P<slug>.*)' 页面的显示路径和保存路径，推荐下面的方式 ARTICLE_URL = '{category}/{slug}.html' ARTICLE_SAVE_AS = ARTICLE_URL PAGE_URL = '{slug}.html' PAGE_SAVE_AS = PAGE_URL CATEGORY_URL = '{slug}/index.html' CATEGORY_SAVE_AS = CATEGORY_URL TAG_URL = 'tag/{slug}.html' TAG_SAVE_AS = TAG_URL TAGS_SAVE_AS = 'tag/index.html' 十四、指定文章或页面URL 在需要指定URL的文章或者页面中包括两个元数据url与save_as，例如： url : pages /url/ save_as : pages /url/i ndex . html *这个代码指定了本篇文章的url为pages/url/index.html ​ ​ 根据上面很容易推断如何将一篇文章设置为网站的主页，如下代码即可实现将 content/pages/home.md 设为主页： Title: [www.yanyulin.info](http://www.yanyulin.info) Date: 2014-01-08 URL: save_as: index.html *另外还可以通过template:关键字来指定要使用的模板。 十五、独立域名设置 详见：http://www.jianshu.com/p/252b542b1abf Godaddy上购买专属域名，用dnspod进行动态域名解析，步骤如下: 步骤1：修改Godaddy中的NameServers的两个地址为dnspod的DNS地址： f1g1ns1.dnspod.net f1g1ns2.dnspod.net 步骤2：在Dnspod中添加一条A记录，指向Github URL username.github.io 步骤3：在Pelican主目录，即上面创建的blog/output/username.github.io目录，添加CNAME文件，在文件中添加你的独立域名。 ​ ​ *注意这里的CNAME建议放在第十二步提到的content目录下的静态子目录 content/extra 下，并在配置文件中添加相关条目。 十六、相关文章、上下文导航 1.打开pelicanconf.py，定义插件目录和启用插件： #加载plugins PLUGIN_PATH = \"plugins\" PLUGINS = [\"sitemap\",\"neighbors\",\"related_posts\"] #sitemap SITEMAP = { 'format': 'xml', 'priorities': { 'articles': 0.7, 'indexes': 0.8, 'pages': 0.5 }, 'changefreqs': { 'articles': 'monthly', 'indexes': 'daily', 'pages': 'monthly' } } #相关文章 RELATED_POSTS_MAX = 10 2.邻居导航，在主题模版中调用如下代码，可根据自己的情况修改： <div class= \"pagination\" > <ul> {% if article.prev_article %} <li class= \"prev\" ><a href= \" {{ SITEURL }} / {{ article.prev_article.url }} \" > ← Previous </a></li> {% else %} <li class= \"prev\" ><a href= \"/\" > ← Previous </a></li> {% endif %} <li><a href= \"/archives.html\" > Archive </a></li> {% if article.next_article %} <li class= \"next\" ><a href= \" {{ SITEURL }} / {{ article.next_article.url }} \" > Next → </a></li> {% else %} <li class= \"next\" ><a href= \"/\" > Next → </a></li> {% endif %} </ul> </div> 3.相关文章： {% if article.related_posts %} <h4> Related Articles </h4> <ul> {% for related_post in article.related_posts %} <li><a href= \" {{ SITEURL }} / {{ related_post.url }} \" > {{ related_post.title }} </a></li> {% endfor %} </ul> {% endif %} 十七、最后，一些比较占空间的资源文件（图片、媒体等）可以用七牛来进行存储管理","tags":"Blog","loc":"articles/2018/blog-使用Pelican基于GithubPages搭建博客教程.html","title":"使用Pelican基于Github Pages搭建博客教程"},{"url":"articles/2018/coding-BuildandInstallOpenDaylightonUbuntu.html","text":"Operating System：Linux x64 / Ubuntu 14.04 Prerequisites：Linux system with Java and Maven installed Chinese version is also available at Ubuntu系统下OpenDaylight源码编译安装 STEP 1, Environment Tuning 1. Install Git tool by command line: sudo apt-get install git-core 2. After the installation of Java and Maven, you need to edit a very important file for OpenDaylight which is named \"settings.xml\". It can customize the behavior of Maven at system level. But we often choose to make it in ~/.m2 folder under your home directory to limit it in user scope： (under ~/ directory) mkdir .m2 cp -n ~/.m2/settings.xml{,.orig} ; \\wget -q -O - https://raw.githubusercontent.com/opendaylight/odlparent/master/settings.xml > ~/.m2/settings.xml You can also use this command instead: curl https://raw.githubusercontent.com/opendaylight/odlparent/master/settings.xml --create-dirs -o ~/.m2/settings.xml 3. A new settings.xml file should now appear in the folder you just created, go and check the content, which should be something similar as below： # gedit ~/.m2/settings.xml <settings xmlns= \"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\" > <profiles> <profile> <id> opendaylight-release </id> <repositories> <repository> <id> opendaylight-mirror </id> <name> opendaylight-mirror </name> <url> http://nexus.opendaylight.org/content/repositories/public/ </url> <releases> <enabled> true </enabled> <updatePolicy> never </updatePolicy> </releases> <snapshots> <enabled> false </enabled> </snapshots> </repository> </repositories> <pluginRepositories> <pluginRepository> <id> opendaylight-mirror </id> <name> opendaylight-mirror </name> <url> http://nexus.opendaylight.org/content/repositories/public/ </url> <releases> <enabled> true </enabled> <updatePolicy> never </updatePolicy> </releases> <snapshots> <enabled> false </enabled> </snapshots> </pluginRepository> </pluginRepositories> </profile> <profile> <id> opendaylight-snapshots </id> <repositories> <repository> <id> opendaylight-snapshot </id> <name> opendaylight-snapshot </name> <url> http://nexus.opendaylight.org/content/repositories/opendaylight.snapshot/ </url> <releases> <enabled> false </enabled> </releases> <snapshots> <enabled> true </enabled> </snapshots> </repository> </repositories> <pluginRepositories> <pluginRepository> <id> opendaylight-snapshot </id> <name> opendaylight-snapshot </name> <url> http://nexus.opendaylight.org/content/repositories/opendaylight.snapshot/ </url> <releases> <enabled> false </enabled> </releases> <snapshots> <enabled> true </enabled> </snapshots> </pluginRepository> </pluginRepositories> </profile> </profiles> <activeProfiles> <activeProfile> opendaylight-release </activeProfile> <activeProfile> opendaylight-snapshots </activeProfile> </activeProfiles> </settings> STEP 2, Build and Install OpenDaylight Controller Project Please keep in mind that here controller really means core controller without many other additional features, such as WebUI(dlux). As for the development of other features in OpenDaylight and if you need dlux, please refer to next STEP. 1.Create a directory for your project and get the source code of OpenDaylight controller: mkdir openDayLight cd openDayLight git clone https://git.opendaylight.org/gerrit/p/controller.git 2.Specify the version of OpenDaylight you want to build and check: cd controller git checkout stable/lithium //here I specify stable/lithium version git branch 3.Make sure your settings.xml file is right in place. Build the code with Internet connecdtion: mvn clean install -DskipTests 4.Now run your controller: cd controller/karaf/opendaylight-karaf/target/assembly ./bin/karaf 5.And after a while you will enter the OpenDaylight command line mode as shown below: opendaylight-user@root> 6.Some useful command lines to check and install features: feature : list - i //show the features which are already installed feature : list //show all available features (installed ones are marked with \"x\") feature : list | grep < keyword > //show features that contains <keyword> feature : install < feature > //install a <feature> STEP 3, Build and Install OpenDaylight Integration Project Integration Project is more like a framework project which is to integrate all other projects into OpenDaylight. With Integration project you can modify or put your own features under this project directory and test with the controller. 1.Download the Integration source code: git clone https://git.opendaylight.org/gerrit/p/integration.git 2.Get into the integration directory and specify the version you want: cd integration git checkout stable/lithium mvn clean install -DskipTests 3.After previous step is done, you may would like to run the controller: cd integration/distributions/karaf/target/assembly ./bin/karaf 4.Finally you can now begin your development and replace original features with your own ones under this directory, after which you would be able to build and run the controller for testing: username@ubuntu:~/developApps/openDayLight/integration/distributions/karaf/target/assembly/system/org/opendaylight$ ls aaa integration neutron sdninterfaceapp usc bgpcep iotdm nic sfc vpnservice capwap l2switch odlparent snmp vtn controller lacp sxp yangtools coretutorials lispflow mapping tcpmd5 didm mdsal ovsdb topoprocessing dlux nemo packetcable tsdr groupbasedpolicy netconf reservation ttp （END）","tags":"Coding","loc":"articles/2018/coding-BuildandInstallOpenDaylightonUbuntu.html","title":"Build and Install OpenDaylight on Ubuntu"},{"url":"articles/2017/tools-WifiHotSpotOnWindows.html","text":"Windows 版本： Windows 7/8/10 前提：电脑装配无线网卡 方法：通过Dos命令行创建WiFi热点，然后启用共享 1.首先确定无线网卡是否支持承载网络（Hosted Network）。在管理员模式的CMD窗口输入命令： netsh wlan show drivers 在输出信息中找到 \"支持承载网络：是\" 则继续。 2.确定电脑是否已经配置承载网络。同样在CMD窗口分别输入命令： netsh wlan show hostednetwork netsh wlan show hostednetwork setting=security 如果看到第一条命令输出已经配置好的WiFi热点的SSID，第二条输出WiFi热点的密码，直接跳到第四步。 3.创建WiFi热点。命令行输入： netsh wlan set hostednetwork mode=allow ssid=WiFi名称 key=WiFi密码 完成后提示承载网络设置成功。 4.启用WiFi热点。在命令行输入： netsh wlan start hostednetwork 完成后提示已启动承载网络。 5.启用WiFi热点共享。打开 \"网络和共享中心\"，在窗口左边栏找到 \"更改适配器设置\"，再在窗口右侧找到刚刚创建的WiFi网络，一般显示为 \"本地连接\"，记住。如下所示 在以太网的网络连接图标上点击右键选择属性，在弹出的窗口上方标签栏点击 \"共享\"。然后在下方确认框中启用 \"允许其它网络用户通过此计算机的 Internet连接来连接(N)\"。如下所示，下拉框中选择刚刚创建的WiFi热点，确定，完成。 （完）","tags":"Tools","loc":"articles/2017/tools-WifiHotSpotOnWindows.html","title":"Windows系统配置WiFi无线热点"},{"url":"articles/2017/coding-Ubuntu系统ApacheMaven安装.html","text":"操作系统：Linux x64 / Ubuntu 14.04 Apache Maven版本：3.3.9 建议预先搭建Java开发环境：详见 《Linux Ubuntu系统下Java开发环境搭建》 1. 前往Apache Maven官网下载最新版本：https://maven.apache.org/download.cgi，本文以apache-maven-3.3.9-bin.tar.gz为例。 2. 在合适的路径下创建文件夹用来存储Maven，本例选择在/opt目录下新建MVN子文件夹。打开Terminal（后文成为T1），输入： cd /opt #进入到opt目录 sudo mkdir mvn #新建一个mvn文件夹 ls #显示成功新建的mvn文件夹 cd mvn #进入mvn文件夹 3.将下载的MVN压缩包拷贝到mvn目录下。新建另一个Terminal窗口（T2）并输入： cd Downloads #进入Downloads文件夹 ls #显示刚刚下载的MVN文件， sudo cp apache-maven-3.3.9-bin.tar.gz /opt/mvn #将文件拷贝到刚刚新建的mvn文件夹中(这里将\"< >\"部分替代为自己对应的MVN文件名，后同) sudo rm apache-maven-3.3.9-bin.tar.gz #删除本目录下的安装包（可选） 4.解压安装MVN，配置环境变量。回到第一个Terminal（T1），输入： ls #显示拷贝过来的MVN安装包 sudo tar -zxvf apache-maven-3.3.9-bin.tar.gz #将安装包解压 ls #显示解压出的MVN文件夹，以及原安装包 sudo rm apache-maven-3.3.9-bin.tar.gz #删除原安装包 sudo gedit /etc/profile #打开etc目录下的profile文件 5.配置全局环境变量。在打开的profile文档末尾添加MVN安装路径（需仔细确认）： #set maven environment export M2_HOME=/opt/mvn/apache-maven-3.3.9 export MAVEN_OPTS=\"-Xmx1024m\" #避免内存溢出错误（可选） export PATH= ${ M2_HOME } /bin: ${ PATH } 6.保存并关闭文档。（注：也可以通过vim 命令编辑etc/profile，打开命令：sudo vim /etc/profile，按 键进入编辑模式， 键退出编辑模式，接着按\":\"再输入\"wq!\"保存并退出；输入\"q!\"不保存退出） 7.启用配置并验证。在Terminal输入： mvn -v 8.显示效果类似如下： Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T08:41:47-08:00) Maven home: /opt/developTools/jvm/apache-maven-3.3.9 Java version: 1.8.0_65, vendor: Oracle Corporation Java home: /opt/developTools/jvm/jdk1.8.0_65/jre Default locale: en_US, platform encoding: UTF-8 OS name: \"linux\", version: \"3.19.0-25-generic\", arch: \"amd64\", family: \"unix\" （完）","tags":"Coding","loc":"articles/2017/coding-Ubuntu系统ApacheMaven安装.html","title":"Ubuntu系统Apache Maven安装"},{"url":"articles/2017/coding-Ubuntu系统Java开发环境的搭建.html","text":"操作系统：Linux x64 / Ubuntu 14.04 Java JDK版本：jdk-8u65-linux-x64.tar.gz 1. 前往ORACLE官网下载最新版本的Java JDK：http://www.oracle.com/technetwork/java/javase/downloads/index.html，默认下载到Downloads文件夹。 2. 在合适的路径下创建文件夹用来存储Java JDK，本例选择在/opt目录下新建JVM子文件夹。打开Terminal（后文成为T1），输入： cd /opt sudo mkdir jvm ls cd jvm 3.将下载的JDK压缩包拷贝到jvm目录下。新建另一个Terminal窗口（T2）并输入： cd Downloads ls sudo cp jdk-8u65-linux-x64.tar.gz /opt/jvm sudo rm jdk-8u65-linux-x64.tar.gz 4.解压安装Java JDK，配置环境变量。回到第一个Terminal（T1），输入： ls sudo tar -zxvf jdk-8u65-linux-x64.tar.gz ls sudo rm jdk-8u65-linux-x64.tar.gz sudo gedit /etc/profile 5.配置全局环境变量。在打开的profile文档末尾添加JDK安装路径（需仔细确认）： #set java environment export JAVA_HOME=/opt/jvm/jdk1.8.0_65 export JRE_HOME= ${ JAVA_HOME } /jre export CLASSPATH=.: $JAVA_HOME /lib: $JRE_HOME /lib: $CLASSPATH export PATH= $JAVA_HOME /bin: $JRE_HOME /bin: $PATH 6.保存并关闭文档。（注：也可以通过vim 命令编辑etc/profile，打开命令：sudo vim /etc/profile，按 键进入编辑模式， 键退出编辑模式，接着按\":\"再输入\"wq!\"保存并退出；输入\"q!\"不保存退出） 7.启用配置并验证。在Terminal输入： java -version 8.显示效果类似如下： java version \"1.8.0_65\" Java(TM) SE Runtime Environment (build 1.8.0_65-b17) Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode) （完）","tags":"Coding","loc":"articles/2017/coding-Ubuntu系统Java开发环境的搭建.html","title":"Ubuntu系统Java开发环境的搭建"},{"url":"articles/2017/tools-InstallAndRunGeditOnMac.html","text":"App description: gedit (App: gedit.app) App website: https://wiki.gnome.org/Apps/Gedit Install from Terminal 1.Run: ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" < / dev / null 2 > / dev / null ; brew install caskroom / cask / brew-cask 2 > / dev / null 2.After the command finishes, run: brew cask install gedit Now Gedit is installed. Run Gedit from Terminal Solution 1. Add the following line to ~/.profile or ~/.bash_profile: export PATH=/Users/<Username>/Applications/gedit.app/Contents/MacOS/gedit: $ PATH Solution 2. Create a script named gedit in /usr/local/bin and make it executable: a. Create a new file: sudo vim /usr/local/bin/gedit b. Add content as below, save and quit: 1 2 #!/bin/bash /Users/<Username>/Applications/gedit.app/Contents/MacOS/gedit c. Make it executable: sudo chmod 755 /usr/local/bin/gedit (END)","tags":"Tools","loc":"articles/2017/tools-InstallAndRunGeditOnMac.html","title":"Install & Run Gedit from Terminal on Mac"},{"url":"articles/2017/blog-网页BackToTop返回顶部按钮的简单实现.html","text":"在较长的网页页面中往往需要一个固定漂浮在显示屏右下侧位置的返回顶部按钮。 下面介绍一种简单实现： HTML 部分： < body > < a href = \"javascript:void(0);\" id = \"scroll\" title = \"Scroll to Top\" style = \"display: none;\" > Top < span ></ span ></ a > ... </ body > CSS 部分： # scroll { position : fixed ; right : 10 px ; bottom : 10 px ; cursor : pointer ; width : 50 px ; height : 50 px ; background-color : #2E435E ; text-indent : -9999 px ; display : none ; -webkit- border-radius : 5 px ; -moz- border-radius : 5 px ; border-radius : 5 px ; } # scroll span { position : absolute ; top : 50 % ; left : 50 % ; margin-left : -8 px ; margin-top : -12 px ; height : 0 ; width : 0 ; border : 8 px solid transparent ; border-bottom-color : #ffffff } # scroll : hover { background-color : #3498db ; opacity : 1 ; filter : \"alpha(opacity=100)\" ; -ms- filter : \"alpha(opacity=100)\" ; } JavaScript 部分： $ ( document ). ready ( function (){ $ ( window ). scroll ( function (){ if ( $ ( this ). scrollTop () > 100 ){ $ ( '#scroll' ). fadeIn (); } else { $ ( '#scroll' ). fadeOut (); } }); $ ( '#scroll' ). click ( function (){ $ ( \"html, body\" ). animate ({ scrollTop : 0 }, 600 ); return false ; }); }); 最后的显示效果可以参照本博客：）","tags":"Blog","loc":"articles/2017/blog-网页BackToTop返回顶部按钮的简单实现.html","title":"网页 BacktoTop 返回顶部按钮的简单实现"},{"url":"articles/2017/blog-CSS伪类contenturl放图片如何改变图的大小.html","text":"遇到过一个问题：用before after 之类的伪类的content里放一个图的链接，如何去改图的大小？比如： . nav ul li : after { content : url ( ../img/nav_fg.png ); } 事实上，如果想要设置前端页面通过content：url显示出来的图片大小，那只能修改图片的大小。因为它是直接读取的图片，并不是代入到html中再显示出来。但可以采用background的方式调整图片的大小，比如本博客中学术社交网站ResearchGate的Logo的CSS显示代码如下： . social a [ href *= 'researchgate.net' ] : before { background-image : url ( './images/icons/researchgate.png' ); background-size : 100 % ; display : inline-block ; margin-right : 2 px ; vertical-align : -3 px ; height : 16 px ; width : 16 px ; content : \"\" ; } 其中 content=\"\", height, width, background-size, display, background-image 都必须显示指定。这样，就可以通过 height, width 来分别设置图片的长和宽了。","tags":"Blog","loc":"articles/2017/blog-CSS伪类contenturl放图片如何改变图的大小.html","title":"CSS伪类content: url放图片如何改变图的大小"},{"url":"articles/2016/tools-InstallWiresharkonUbuntu.html","text":"1. Download WIreshark source code on website: https://www.wireshark.org/download.html 2. Extract files into targeted folder: tar -xvf wireshark-1.10.7.tar.bz2 3. Install compiling tools and dependencies: sudo apt-get install build-essential sudo apt-get install libgtk2.0-dev libglib2.0-dev sudo apt-get install checkinstall sudo apt-get install flex bison sudo apt-get build-dep wireshark sudo apt-get install qt5-default sudo apt-get install libssl-dev sudo apt-get install libgtk-3-dev 4. Go to www.tcpdump.org and find newest version of libpcap(e.g., libpcap-1.5.3.tar.gz): #tar -xvf libpcap-1.5.3.tar.gz #cd libpcap-1.5.3.tar.gz #./configure #make #make install 5. Go to wireshark folder: ./autogen.sh ./configure --with-ssl --enable-setcap-install make make install","tags":"Tools","loc":"articles/2016/tools-InstallWiresharkonUbuntu.html","title":"Install Wireshark on Ubuntu"},{"url":"articles/2016/notes-法国的一些精油品牌.html","text":"法国精油品牌： Florial (Florihana) (芙梦丽娜) L'OCCITANE ( 欧舒丹 ) Sanoflore (圣芙兰) CAMENAE (嘉媚乐) NUXE ( 欧树 ) SISLEY ( 希思黎 ) 1. Florial (Florihana) —— F家 品牌： 在欧洲被视为法国第一医疗等级的有机认证植物精油品牌，多年来一直深受着各国芳疗界的喜爱。拥有世界上独一无二的特殊蒸馏技术，采用人工采集和产油率极低的低温、低压、缓慢的蒸馏技术来提炼精油。包装瓶选用一种特殊的绿色玻璃来装载精油，此种瓶子不但可阻挡一般的阳光，还有过滤紫外线和红外线的作用，方便精油更好的保持原型状态。此外，F家的有机精油品种丰富，其中尤其纯露做的非常好，属于世界顶级行列。唯一的一点瑕疵是这家的产地有些并不是非常好（其实也很好理解，算是多品种的机会成本吧）。 公司： J.E Internatioanl (Florihana、Florial商标所有人)公司总部设立在法国的南部，于国家级自然保护区内的科斯高山（Caussols plateau）上。创办人MR. Durante Alain 系工程师出身。自1993年开始从事精油萃取及芳疗推广事业，用近15年的时间，终于创立出Florial和Florihana品牌。 明星产品： 永久花纯露 ( HELICHRYSUM ITALIAN ORGANIC ) 标签： 法国知名精油品牌 2. L'OCCITANE—— 欧舒丹 品牌： 全称L'OCCITANE EN PROVENCE（法语发音：[lɔksiˈtan ɑ ̃pʁɔvɑ̃s]，意即\"普罗旺斯的欧舒丹\")。产品是以普罗旺斯丰富的自然草本植物为原料，用优质的植物由传统方法制造开发而成。每一个产品系列都有其独特传奇：薰衣草、橄榄、马鞭草及蜂蜜节发扬法国普罗旺斯的传统，蜡菊细诉科西嘉岛的故事，乳木果油是非洲的传奇瑰宝。今天， 欧舒丹已成为在全球近60个国家开设逾550家分店的国际知名香氛护理品牌。 公司： 是一家专门制造及售卖个人护理产品及家居产品的国际零售企业，主要生产基地设于法国马诺斯克（Manosque）。 公司成立于1976年， 创办人为奥利维埃·博桑（Olivier Baussan）， 他希望建立一家保留并弘扬家乡普罗旺斯传统的公司。公司名字L'OCCITANE在法语中的意思是\"来自欧西坦尼亚的女人\"。欧舒丹希望\"透过提供独特的个人护理及家居产品，成为提倡地中海式舒适安康感觉的国际模范\"，并以\"舒适愉悦\"、\"真实纯净\"及\"关怀尊重\"等为企业理念。 明星产品： \"Aromachology\" 芳香身心疗法系列：以多种精油混合制成，将\"冥想\"的意境贯穿其中，能帮助身体与大自然沟通。整个系列有沐浴、洗发、润肤、按摩油和蜡烛等产品，其中以沐浴品最为畅销。 标签： 法国知名护理品牌 3. Sanoflore —— 圣芙兰 品牌： 法国芳香界一个很有地位的品牌，所有的原料都采自以有机种植的方式培育出的植物，是全球唯一全系列商品皆获得欧盟Ecocert与Cosmebio有机认证的品牌。SANOFLOR还有很多美容护肤类的产品如：玫瑰面油，按摩油，日霜，晚霜，眼霜等都用的有机植物的精华，而且最值得一提的是：它家产品里凡是需要添加水份的，都是添加的100%有机的花水。SANOFLORE共有6种花水，玫瑰，薰衣草，洋甘菊，橙花，金缕梅，矢车菊。目前，SANOFLORE产品涉及花草类（花草茶，花草药包）、芳香疗法（精油，花水）、有机美容护肤品和天然香料。 公司： 全世界最大有机植物原料供机商，就连法国SISLEY、DARPHIN，甚至是澳洲AESOP的精油成分及原料都来自于它。Sanoflore法文的原意指的是：\"健康的花朵\"。1972年，瑞士籍的地球及自然科学与地质学与商业管理研究所博士RodolpheBALZ，在法国普罗旺斯Drome的核心地带一片零污染的山丘上成立了第一座实验性的花园SanofloreLaboratory，生产出第一瓶花水；1986年，SANOFLORE正式成立了专门研究有机产品的实验室；1998年，Daniel RICHARD家族加入经营，将SANOFLORE介绍给全世界。 明星产品： 花水系列 标签： 法国知名精油品牌，世界最大有机植物原料提供商 4. CAMENAE —— 嘉媚乐 品牌： 源自法国普罗旺斯纯粹的人文精髓的化妆品品牌，应该算是最接中国\"地气\"的法国精油品牌之一了。自2003年进入中国市场以来，在一年的时间不下200余家专卖店和专柜相继开业，至今CAMENAE应该算是国内精油护肤品领域的佼佼者。2007年CAMENAE嘉媚乐成功获得欧盟ECO-CERT国际有机认证。品牌理念：善用精油，关注心灵，回归天然。 公司： CAMENAE，法国知名精油品牌，1970年创立于法国的普罗旺斯。从1970年创立起，至今已发展成为拥有逾3000家门店的超级连锁体系。2003年8月，CAMENAE在北京国贸开张了第一家中国旗舰店，宣告这一欧洲个人护理品牌正式挺进中国，同时启动中国区特许经营项目。 明星产品： \"橄榄精华系列\" 标签： 法国知名护理品牌，中国知名品牌 5. NUXE —— 欧树 品牌： 法国纯植物美容品牌，名字取自NATURE（自然）+LUXE（奢华），意喻该品牌是自然与奢华的完美的结合。NUXE 崇尚自然，创立伊始便坚持独创，注重优选成分，不一味追逐潮流，成为天然美学，回归自然的领导品牌。品牌理念：自然和大胆，效率和真实，性感与奢华，力求将植物的功效发挥到极致，结合\"自然、健康、美丽\"三大护肤要素，共同复兴先锋化妆品理念。在媒体和娱乐圈内对其给予的评价颇高。 公司： 由巴黎的一位药技师兼芳疗及植物疗法专家在1957年所创立，成立以来，研发了许多简单、温和、有效的美容保养品。企业精神：超越流行的限制，而秉持着绝对独立自主。1989 年由崇尚植物与芳香疗法的知名法国女企业家Aliza Jabes收购，经医疗级别的精密制作过程和严密的企业行销与品质塑造，更促使NUXE成为天然美学的教主品牌。 明星产品： 蜂蜜洁面系列，睡莲面霜，植物鲜奶面霜，花水系列等 标签： 法国知名纯植物美容品牌 6. SISLEY —— 希思黎 品牌： 品牌名称Sisley来自於19世纪法国印象派画家Alfred Sisley，因此可以想像这是个流著热血以及多情艺术的品牌。Sisley所有产品均以植物萃取精华与植物香精油作为主要成分，配以其独有配方研制而成，在品质、绝对的安全性和适用性上享有盛誉。产品主要涉及护肤、彩妆、美发和香水（希思黎夜幽情怀女士香水）。理念和定位：\"用科学印证植物美容的传说，以优质尊贵的产品，献给讲究的人士\"（通俗的说就是坚持高品质，然后高价位，护肤品中尊贵与优雅的经典代表）。 公司： 在1976年由法国修伯特．多纳诺伯爵创立，以当时欧洲最新的植物美容学为基础，成功地研创出来的植物性护肤品牌。是现今极少数仍由家族拥有、经营的化妆品品牌。全世界所有的Sisley护肤产品均出自法国巴黎工厂，以确保品牌产品的一致性。产品上市前必先经过皮肤科医生的测试，以确保产品的安全性。Sisley是少数被皮肤医学家认定为最安全的护肤品；即使是过敏性与敏感性肌肤，也可安心使用。 明星产品： Ecological Compound，Botanical D-TOX Detoxifying，Express Flower Gel, etc. 标签： 法国知名植物美容品牌 参考: 1. 十六番：法国购物攻略 2. 各品牌百度百科 3. 各品牌Wikipedia 4. 新欧洲.战斗在法国 5. 各品牌官网","tags":"Notes","loc":"articles/2016/notes-法国的一些精油品牌.html","title":"法国的一些著名的精油品牌"},{"url":"articles/2016/tools-InstallVMwareWorkstationinUbuntu14.04.html","text":"1. Use apt-get update system: linuxidc@localhost:~$ sudo apt-get update linuxidc@localhost:~$ sudo apt-get upgrade 2. Download VMware Workstation bundle. 3. Make bundle executable: linuxidc@localhost:~$ chmod a+x VMware-Workstation-Full-11.0.0-2305329.x86_64.bundle 4. Run the bundle: linuxidc@localhost:~$ sudo ./VMware-Workstation-Full-11.0.0-2305329.x86_64.bundle 5. Installation:","tags":"Tools","loc":"articles/2016/tools-InstallVMwareWorkstationinUbuntu14.04.html","title":"Install VMware Workstation in Ubuntu 14.04"},{"url":"articles/2016/coding-Shiro.html","text":"0. GOALS - Provide user authentication and authorization for multi-tenant scenarios - Provide easy-to-maintain data storage with only one database - Provide domain-differentiated, credential-based authentication - Provide domain-differentiated, role-based, service-specific authorization; 1. QuickStart with Apache Shiro - English Documentation - Chinese Documentation - Example Applications - Architecture: 2. Environment Prerequisites Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T17:41:47+01:00) Maven home: /Library/Maven Java version: 1.7.0_79, vendor: Oracle Corporation Java home: /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre Default locale: en_US, platform encoding: UTF-8 OS name: \"mac os x\", version: \"10.11.2\", arch: \"x86_64\", family: \"mac\" 3. Apache Shiro Maven Dependency <dependency> <groupId> org.apache.shiro </groupId> <artifactId> shiro-core </artifactId> <version> 1.1.0 </version> </dependency> <dependency> <groupId> org.slf4j </groupId> <artifactId> slf4j-simple </artifactId> <version> 1.6.1 </version> <scope> test </scope> </dependency> 4. MySQL QuickStart 1. Install MySQL on Mac 2. 修改Root密码 3. W3Schools SQL Tutorial 4. W3School中文SQL教程 5. RUNOOB MySQL教程 5. Create Tables 1.User Table: 2.Domain_User Table: 3.User_Role Table: 4.Permission_Domain_Role Table: 6. JDBC Setup and Code Customization 1.Maven Dependency: <dependency> <groupId> mysql </groupId> <artifactId> mysql-connector-java </artifactId> <version> 5.1.25 </version> </dependency> <dependency> <groupId> com.alibaba </groupId> <artifactId> druid </artifactId> <version> 0.2.23 </version> </dependency> 2.Rewrite getPermissions method in jdbcRealm protected Set < String > getPermissions ( Connection conn , String username ) throws SQLException { PreparedStatement ps = null ; Set < String > permissions = new LinkedHashSet < String >(); try { ps = conn . prepareStatement ( permissionsQuery ); ps . setString ( 1 , username ); ResultSet rs = null ; try { // Execute query rs = ps . executeQuery (); // Loop over results and add each returned role to a set while ( rs . next ()) { String permissionString = rs . getString ( 1 ); // Add the permission to the set of permissions permissions . add ( permissionString ); } } finally { JdbcUtils . closeResultSet ( rs ); } } finally { JdbcUtils . closeStatement ( ps ); } return permissions ; } 3.Add getUserDomain method in jdbcRealm public Set < String > getUserDomain ( Connection conn , String username ){ PreparedStatement ps = null ; Set < String > domains = new LinkedHashSet <>(); try { ps = conn . prepareStatement ( userDomainQuery ); ps . setString ( 1 , username ); ResultSet rs = null ; try { rs = ps . executeQuery (); while ( rs . next ()) { String domainID = rs . getString ( 1 ); domains . add ( domainID ); } } catch ( SQLException e ) { e . printStackTrace (); } finally { JdbcUtils . closeResultSet ( rs ); } } catch ( SQLException e ) { e . printStackTrace (); } finally { JdbcUtils . closeStatement ( ps ); } return domains ; } 4.Rewrite doGetAuthenticationInfo method in jdbcRealm protected AuthenticationInfo doGetAuthenticationInfo ( AuthenticationToken token ) throws AuthenticationException { VTNAuthNToken upToken = ( VTNAuthNToken ) token ; String username = upToken . getUsername (); String domainID = Integer . toString ( upToken . getDomainId ()); // Null username is invalid if ( username == null ) { throw new AccountException ( \"Null usernames are not allowed by this realm.\" ); } Connection conn = null ; SimpleAuthenticationInfo info = null ; try { conn = dataSource . getConnection (); Set < String > domains = getUserDomain ( conn , username ); if (!( domains . contains ( domainID ))){ throw new AuthenticationException ( \"Domain not found\" ); } String password = null ; String salt = null ; switch ( saltStyle ) { case NO_SALT : password = getPasswordForUser ( conn , username )[ 0 ]; break ; case CRYPT : // TODO: separate password and hash from getPasswordForUser[0] throw new ConfigurationException ( \"Not implemented yet\" ); //break; case COLUMN : String [] queryResults = getPasswordForUser ( conn , username ); password = queryResults [ 0 ]; salt = queryResults [ 1 ]; break ; case EXTERNAL : password = getPasswordForUser ( conn , username )[ 0 ]; salt = getSaltForUser ( username ); } if ( password == null ) { throw new UnknownAccountException ( \"No account found for user [\" + username + \"]\" ); } info = new SimpleAuthenticationInfo ( username , password . toCharArray (), getName ()); if ( salt != null ) { info . setCredentialsSalt ( ByteSource . Util . bytes ( salt )); } } catch ( SQLException e ) { final String message = \"There was a SQL error while authenticating user [\" + username + \"]\" ; if ( log . isErrorEnabled ()) { log . error ( message , e ); } // Rethrow any SQL errors as an authentication exception throw new AuthenticationException ( message , e ); } finally { JdbcUtils . closeConnection ( conn ); } return info ; } 7. Setup Shiro.ini Configuration File [main] #authenticator authenticator = aaa.authn.VTNAuthenticator #(Customized) authenticationStrategy = org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy authenticator.authenticationStrategy = $authenticationStrategy securityManager.authenticator = $authenticator #authorizer authorizer = aaa.authz.VTNAuthorizer #(Customized) permissionResolver = org.apache.shiro.authz.permission.WildcardPermissionResolver authorizer.permissionResolver = $permissionResolver securityManager.authorizer = $authorizer #Realm jdbcRealm = aaa.realms.MySQLRealm #(Customized) dataSource = com.alibaba.druid.pool.DruidDataSource dataSource.driverClassName = com.mysql.jdbc.Driver dataSource.url = jdbc:mysql://localhost:3306/vtn dataSource.username = root jdbcRealm.dataSource = $dataSource securityManager.realms = $jdbcRealm jdbcRealm.permissionsLookupEnabled = true #SQL Queries jdbcRealm.authenticationQuery = SELECT password FROM user WHERE user_name = ? jdbcRealm.userRolesQuery = SELECT role_id FROM user_role left join user using(user_id) WHERE user_name = ? jdbcRealm.permissionsQuery = SELECT distinct permission_id FROM perm_domain_role left join domain_user using(domain_id) left join user using(user_id) WHERE (domain_id, role_id) IN ( SELECT domain_id, role_id From user left join user_role using(user_id) left join domain_user using(user_id) WHERE user_name = ?) 8. Tips about SQL permissionsQuery in INI file: 1. Query with same parameter at two places: SELECT T . P FROM ( SELECT distinct permission_id as P , role_id AS R FROM perm_domain_role left join domain_user using ( domain_id ) left join user using ( user_id ) WHERE user_name = ? ) AS T WHERE T . R IN ( SELECT role_id FROM user_role left join user using ( user_id ) WHERE user_name = ? ) 2.Optimization with only one parameter: SELECT DISTINCT permission_id FROM perm_domain_role left join domain_user using ( domain_id ) left join user using ( user_id ) WHERE ( domain_id , role_id ) IN ( SELECT domain_id , role_id FROM user left join user_role using ( user_id ) left join domain_user using ( user_id ) WHERE user_name = ? ) 9. Result: Finally, you can easily test that each user has different services authorized by Shiro according to its tenant domain and its role. for ( VTNAuthNToken token : userTokenList ) { Mappable userRequest = new MappableMsg ( null , null , token ); for ( String service : servList ){ userRequest . setServID ( service ); if ( IShiro . getInstance (). isAuthorized ( userRequest )){ String entry = \"Domain \" + token . getDomainId ()+ \": \" + token . getUsername ()+ \": \" + service ; authZResult . add ( entry ); } } } for ( String i : authZResult ){ System . out . println ( i ); } Output: Domain 1: admin: vtn:topo:create Domain 1: admin: vtn:topo:read Domain 1: admin: vtn:topo:update Domain 1: admin: vtn:topo:delete Domain 1: admin: system:vtn:create Domain 1: admin: system:vtn:update Domain 1: admin: system:vtn:delete Domain 1: admin: serv:firewall:create Domain 1: admin: serv:firewall:read Domain 1: admin: serv:firewall:update Domain 1: admin: serv:firewall:delete Domain 1: boss: system:vtn:read Domain 2: tenant1: vtn:topo:create Domain 2: tenant1: vtn:topo:read Domain 2: tenant1: vtn:topo:update Domain 2: tenant1: vtn:topo:delete Domain 2: tenant1: serv:firewall:create Domain 2: tenant1: serv:firewall:read Domain 2: tenant1: serv:firewall:update Domain 2: tenant1: serv:firewall:delete Domain 2: guest1: vtn:topo:read Domain 2: guest1: serv:firewall:read Domain 3: tenant2: vtn:topo:create Domain 3: tenant2: vtn:topo:read Domain 3: tenant2: vtn:topo:update Domain 3: tenant2: vtn:topo:delete Domain 3: guest2: vtn:topo:read","tags":"Coding","loc":"articles/2016/coding-Shiro.html","title":"Apache Shiro Multi-tenancy with JDBC MySQL"},{"url":"articles/2016/notes-心路.html","text":"城市：雷恩 2016年2月1日晚，距国内过新年还有7天。原本只是想要找一封早时候的项目电邮，结果不小心没把持住，泛滥着感慨时光飞逝的小情绪翻阅了一遍以往的邮件，感觉就像是在看旧照片，就像把从大一开始到现在的生活重新走了一遍。至今有很多需要感谢的人，值得纪念的事，我不想在忙碌中就这样让它们随时间流走。因为手里的东西总是忙不完，那些让你成长的却不总有机会不被遗忘。 2012-09-01/2013-08-27 大三 2012年大二暑假，由于本专业大类被限制转专业，我决定通过考取思科认证来自学网络技术。11月，虽然国创(SIETP)项目才刚立项一个月，SRTP项目已经立项半年，但是学习的重心从十月份起已经向网络方向偏移，整天脑子里除了思科的路由交换就是国创的建筑涂料，闲暇之余才能稍微顾及一下专业课程实习和考试，而SRTP项目已经打算彻底水漂过去了。这个过程持续了一年，准备出国又花了一年，期间发生了许多事——得到了许多人的帮助，也犯了不少傻事。 2012-09-Inquiry to Prof. Bai 我希望在本科毕业后往网络工程方向走。我的专业是农业资源与环境，但出于个人兴趣并且经过了慎重考虑后，我想在大学接下来的两年内考取CCIE，可自己目前几乎是零基础，暂时打算到欧朋兰博先报一个CCNA的培训班作为入门。我有一位高中同学（专业与计算机网络无关）在今年暑假拿到了CCIE认证，虽然有了他的建议和引导可以少走些弯路，但他毕竟不在自己身边许多事情还是需要自己去摸索。下面是我想咨询您的问题： 1. 学校有开设相关的培训课程吗？如果没有我又该如何充分利用本校的设备或者资源呢？ 2. 浙大有与CCIE对口的网络工程方面的硕士学位吗？或者其它与CCIE相关的深造项目或计划？ 3. 同学说CCIE的工作经验（项目资历）很重要，花两年时间去读研和工作那种更利于自己今后发展？ 4. 不考虑能力问题，拿到CCIE后出国是否是最佳选择？如果这就是我的规划，自己应该早作哪些准备？ 建议: 我印象中没有这种培训，不过为保险起见你可以打电话问问计算机学院办公室。社会上倒是有，但培训费用有点贵。我记得CCIE认证有面试的，要求当场调试网络的，所以肯定要有设备进行实验，但是学校机房里并没有这些设备的，估计要去问问计算机学院的相关实验室，具体哪里有我也不清楚。CCIE只是一个认证，硕士学位的培养不可能只局限于此的。具体有关计算机学院的硕士专业方向你可以查询计算机学院网站。CCIE认证拿到一般就是去工作赚钱了吧，没有必要再去读什么研了。因为读研主要就是学术方向，CCIE主要还是动手能力。如果出国去工作的话，是可以考虑的，不过去大城市如上海也一样可以赚大钱；如果出国去读研，那CCIE没有什么用。我印象中前几年CCIE很吃香，因为拿到这个认证的人非常少，现在什么行情我就不太清楚了。我觉得你以后的方向不能仅局限于这个CCIE，可以考虑把面放得更广一些，搞计算机主要是时效性太短，学东西花了很多精力很快就淘汰了，又得不断地学新东西，很累的。这一点不像医学、外语，可以吃老本。 2013-05-Inquiry to Prof. Wu 我对网络技术很感兴趣，今后想要成为一名网络工程师。但在就业之前，我渴望自己能够是\"CCIE+网络工程硕士\"。但是我在网络工程领域的硬件储备基本为零，而作为敲门砖的CCIE证书，虽然我在很努力地准备，但也要等到暑假才能考到。我想申请贵院\"本校其他专业免试研究生\"的资格…… 虽然你以前的专业和你想转换的不同，但你对网络研究方向感兴趣的话肯定能有所建树的，我倒很愿意推荐你来我实验室研究、学习。你的英语考级情况如何？保送研究生的资格是否可以争取到？你们学院的老师我倒有些熟悉的，可以寻求一些帮助的。你若情况明朗的话可以来我实验室学习了，了解一下基础研究情况，并推荐你看一些基础性的教程，并与师兄们讨论、求教，相信你会很快有所提高的。我实验室在研的下一代网络前沿技术今后将会非常之普及的，这方面人才的储备的含金量会愈来愈高的。建议可以进一步进行硕博连读的计划。近期有诸多大公司来我们这里合作，其中需要我们这个方向的博士研究生，我这里在学院申请到了3位硕博连读的招生指标，其中1个我想到时给你，这样你后面的研究工作和今后的就业就比较吻合一致的，目标也更加清晰了；另外需要到国外进修的话我这里也是比较便捷的，美国加州大学、西北大学、阿拉巴马大学都有老师在这里合作研究。硕博连读的保研可以申请的吧，目前说要招收导师的确认方可。 2013-05-Kind Remind from Prof. Pan 你花了四年学专业, 却要从零开始学网络, 这种执业证书计算机专业学生不看重, 培训机构兼钱看重，只是浪费了你爸的血汗钱！真正要学网络要学一个计算机学科的知识，改行而出成绩要比別人化多倍的精力和辛勤汗水！行行出状元, 为何要换专业？新材料研究是一很需要方向！ 因此，要三思而行，除非所学专业的确很难找到工作？！ 2013-09/2014-06 大四 2013-09-Inquiry to Dr. Ning 暑假期间我还在备考，所以没来得及联系您，前不久刚刚考完，下一步打算着手准备出国。出国的这个决定下得比较仓促，所以对出国资金，选校定位，文书套磁，奖学金等都认识不深，有关的一些准备工作以及学业规划也并不成熟。因此希望能听取你的指点和引导，从而少走弯路。我以后打算从事IT（网络）方面的工作，所以希望最好能够直接申请到美国CS方面的硕士OFFER，但是由于是跨专业，而且托福和GRE才刚刚开始准备，所以时间非常紧张，并且应该可能会要拖个半年一年，来准备英语成绩，选修计算机专业课，还有积累相关的项目或者实习经历。如果英语成绩能够顺利考出来的话，今年12月底到明年1月份初试申几所院校，如果计划不顺利或者录取结果不理想的话再等明年春季那一批招生，并继续冲刺英语考试，同时可以去积累一下实习经历或者可能的话跟着计院老师获取科研经历。关于费用的问题，我们家里的经济条件并不宽裕，所以我和爸妈非常关心这一点，当然选校的时候也必须要考虑这一点。但是目前为止我对留学美国的花费还没有一个非常清楚的认识和概念，您可以向我具体的介绍一下吗？鉴于经费的问题和选择的空间，听同学说加拿大的花费稍微低一些，我是否有必要也同时申请加拿大的院校呢？另外同时以自己本科的专业去申请几所院校的环境类专业，然后再视情况考虑转到CS是否是一种可能的合理的选择？ 建议： As you understood, your background is inconsistent with what you try to pursue and your family is not able to provide full financial support for your graduate study oversea. In general, the cost for each credit of a graduate course is about $1000 - $2000 for international students and at least 12 credits are required for a full-time graduate student. Lodging and boarding costs additional $10k per year. That's reality. So you may think about it around the way or alternate approach(es). \"以自己本科的专业去申请几所院校的环境类专业，然后再视情况考虑转到CS\" might be the alternate approach, through which you could get a school financial support. I like your attitude for planning your long-run goals. For now, however, you should concentrate on getting as high as possible scores on TOEFL and GRE, which will help you get admitted into a college graduate program and financial support from the college. Once you get high enough scores with them, you can think of what colleges and programs you should apply for. 关于套磁, you should have done certain research on particular professional fields through these you should frequently refer the articles published in professional journals. Then you can naturally get in touch with those authors of the articles to inquire their recent progress, etc. 2013-10-Inquiry to Mr. Li 很抱歉近期没能关注到Autodesk公司在我们学校的校招情况，对贵公司的职位需求不太了解，所以希望先把简历发给您并同您建立联系，望前辈多多批评指正。 建议： ……不过你开发编程方面经历较少。如果我这个理解没错，而且你又希望在IT业方面尝试一下发展的话，看来你比较适合在公司的IT部门工作，进行网络方面管理，不知道你是否同意。我们公司最近招人并不多，每两周会发布一次职位需求列表，最近的一次没有看到IT部门的职位，我会留意邮件，如果有合适的职位一定会帮你推荐。不过现在十月份，距离毕业还早，你大可以多尝试一些其他更加对口的公司，比如思科华为这些。或者准备考研（如果你想的话）。有问题就给我写信，祝好运！ 2013-11-Inquiry to Mr. Zhuliu & Mr. Yue 10月底已经拿到华为的offer了，但是还是非常想出国念IT，所以虽然转专业难度比较大，但还是想考英语再全力去试着申一申，如果实在时间来不及或者结果不合适的话就只能到华为工作几年再出国了。浙大这边有个和KTH的4+2的项目我已经报名了，12月17日对方会来我们学校面试，希望顺利吧!以上是我目前的状态和打算。CV就拜托你了，另外就你对美国大学的了解，能否对我的转专业申请提一些建议，比如说美国学校非常注重什么；我还可以怎样去弥补转专业这种情况带来的劣势；还有申硕士的话套磁对申请结果会有很大的影响吗，（比如要是我的毕设课题是软件定义网络SDN这一块，而某个教授也是研究这一块）。 Zhuliu： 在你面前有很多很好的选择，我相信无论你走哪一条路，都会一如既往的精彩。我自己不是跨专业申请的，只是借原来的专业入了学校的门，然后又背弃师门，转行做码农。所以对于你申请CS专业，我的帮助比较有限。我跟一个CS的同学讨论了你的情况，大家总结了一些想法。 第一，跨专业申请，尤其是跨度较大的申请确实难度很大，因为导师会顾虑学生的专业基本功。但同时，学校和院系也是很欣赏多样性的。我们这里有EE教授研做心理学课题的，语言学教授做自然语言计算处理的。包括我的那位同学，他本科是机械系做机器人和电路的。所以跨专业申请，硬攻CS的话，是要打diversity的牌。我觉得这点你已经做得比较好了，做了CS与你本专业结合的课题。我也相信CS技术可以在你所熟知的专业领域里有很多美妙的应用。（我自己对于GIS也很感兴趣，现在python的兴起正在改变Earth Science整个学科的面貌，很多地理信息的教授都感觉自己落伍了，在学校里找CS相关的学生做研究助理）。跨专业或许是一个短板，但如果你把它与CS结合得好，突出自己跨学科解决问题的能力和学习能力，并且强调自己应用CS的学术深度，就可以扬长避短。兴许有教授恰好有合你胃口的跨专业项目，这样就最好了。 第二，也得考虑\"曲线进入\"的方式。CS核心专业的录取量不大，而且竞争激烈。但以别的专业进入CS强校，不失为一种办法。美国大学有很大的自由度。尤其是对于硕士学生，只要修了符合要求的课程，就能转入CS相关的专业（有时候EE反而比较灵活合包容，现在EE的也都在coding）。 我身边有同学刚进来就修读CS的课程，第二年顺利从civil转到EE。也有同学直接从civil转到了CS。申请的时候违心地\"欺骗\"一下老师的感情也是无妨的。只要不是骗phd funding，套个硕士录取，然后进来就跳，我觉得也是无可非议的。从这个角度考虑，申请你的本专业（与CS结合的更好），或者CS边缘的专业（比如CMU有不少非CS核心的专业可以考虑），或者EE的某些方向（比如网络）可能会增加你进入学校的把握。 综合这两条，你的申请思路可以是两者结合的。很多学校都是以院系为单位招生录取的。所以你可以准备两种倾向性的材料分别投给CS和其他学院。只要有一种方式成功，便是胜利。 对于申请CS专业的CV和PS，你要把自己的主体内容写得跟科班出身的人差不多。你可以简要梳理一下你的专业基础，比如，会哪几门语言，分别什么程度（proficient, experienced)。算法设计的课程或项目。Object Oriented Programming方面的经验。还有就是CS某个子领域的研究。比如你擅长network那块，你可以把相关的课程经历和具体的project都梳理到一起。你能受到华为的青睐，肯定有拿得出手的相关项目，这个子领域的学识至关重要，要突出强调这个，让教授觉得你有干货，并且有志于研究下去（以申请phd的态度申请硕士）。教授在确定了你基础过关的情况下，就是看志趣相投了。然后，还是那一点，科班一样的简历之外，也不可能回避本专业的内容。这个和找工作不一样，我可以只字不提civil专业，说自己是Engineering的。学术录取对于你既往的专业还是会调查的详细清楚的。这就需要像前面所说的那样扬长避短，你要强调你的专业学习中融入的CS是多么的有深度。以你本专业做外壳，大讲你的CS内涵。 而对于申请与你专业比较相近的方向，则还是以本专业为坚实基础，CS作为你的拿手好戏。你取得了本专业的学位，有优秀的成绩，而且做了很多跨学科的课题都非常时髦。是的，现在美国整个学术圈都在追求量化和模拟，你的coding技能可能是你本专业很多老板所垂涎的。我想这种类型的简历，你写起来应该得心应手。再有一点就是投其所好。如果你是把CS作为锦上添花的，那么可以略写专业术语和具体内容，强调实用和宽度（怎么在你的专业里用的好）。比如你的Sql DB的经历对于GIS等信息类但非CS专业，是很加分的。但是对于CS专业，就要浓缩到你的干货上去（你的network方向），因为看简历的对方是行家，他所关心的是子专业的匹配。你最强势的，甚至有可能作为phd课题的CS项目就要详细的写，突出亮点。次要的可以省略和带过。 对于你现有的简历，我觉得这里已经有足够丰富的素材了，充分证明了你的勤奋和才能。接下来的就是为两种战术挑选素材, 量身定做了。至于找CS专业简历的模板，你可以google到很多专业人士的（码农的CV很多），你可以模仿他们的笔调去写自己内容，如果顺带用一下latex写的话，给人专业的感觉（这个不是很重要）。还有一点，除非是对方认识的知名教授，一般都不必列举你的指导老师的名字。这样占篇幅，而且更给对方疏离感，这里你是明星！还有详略的控制。要做的精简的基础上，让对方大概了解到你做了什么工作，用了什么技术。比如你的MySQL项目，你指出的GUI，一看就很明显了，确实不必多解释，但如果你说你用java swing或者php，ruby做web interface那就更令人信服。但main funciton modules就是很含糊的概念，你是负责DB和你们的program交互的module，还是数据与DB交互前的其他处理（如果是，那么可能用到什么核心算法或数据结构，你也可以做文章）。同理，你在implement intellecutal queuing system时候的主要解决的难题是什么，核心算法借鉴了什么。这些都是可以套用术语简要的交代清楚的。另外，你用动词开头的描述很好，确实是这样的规范。可以改进的地方在于把动词替换成高级的同义词，比如把helped换成assisted。 Yue： 华为offer比较不错，实在不行先在国内工作下也还好，国外很多人都是有几年工作经验再读硕士的。我稍微看了下，标注了一些地方可以改下，但还建议你可以自己再仔细修改，并且和更多人一起相互修改，然后找更专业的人士帮忙修改。另外注意写经历时尽量能量化成果，以便更好地differentiate yourself。还可以在网上搜下顶尖美国大学的CV模板，对照着自己的改下。你要转到CS/IT相关方向是吧，建议你在简历里再加上你熟练运用的编程语言、计算机软件吧。我感觉申美国硕士现在不是特别难，美国高校最近招硕士比较多（水）一些，虽然未来扩招的趋势不太可能持续。要转专业的话，相关专业的课程、科研项目、竞赛成果、实习工作经验、CS好教授的推荐信可能会比较有帮助（最好这些都是在国际上认可的），这些估计美国学校都会看重。陶瓷我估计对申硕士帮助不大，如果你想过去跟老师做点课题、争取RA的话，还是可以套的。 2014-04-From Mr. Chisyliu 我个人觉得 学习internet technology本身不错 不过不要只注重网络个体 而要同时学习相关的实现方式 例如 网络应用 java或者数据库 网页开发之类的编程 这样毕业时候自然较好找工作 法国不是非常了解 但学位本身并没有你想象那么重要 主要是你需要找到合适的公司实习或者论文 并且把编程学好 无论你学习什么专业 基本上大学都是教授技术本身 而一般较少教授实现的手段 你所需要的就是找公司实习去强化实现手段 就是所谓的写程序 工程师学位重点并不是学位 而是强制的intern跟法语","tags":"Notes","loc":"articles/2016/notes-心路.html","title":"在难搞的日子里他们这样对你说"}]};